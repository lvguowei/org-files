#+TAGS: ENGLISH(e) FINNISH(f)

* Languages
** Finnish
*** FinnishPod101                                                   :FINNISH:
    - vihannes
    - paprika
    - parsakaali
    - porkkana
    - kurkku
    - lehtisalaatti
    - sipuli
    - peruna
    - soijapapu
    - pinaatti
      Entered on [2014-10-06 Mon 20:28]
*** Suomen mestari                                                  :FINNISH:
**** Minkämaalainen sinä olet?
     - Pedro, minkämaalainen sinä olet?
     - Minä olen brasilialainen. Minkämaalainen sinä olet?
     - Minä olen venäläinen. Entä Alex, mistä sina olet kotoisin?
     - Minä olen kotoisin Etelä-Afrikkasta.
     - Mitä kieltä sinä puhut?
     - Minun äidinkieli on englanti. Puhun myös vähän espanjaa.
     - Pedro, onko sinun äidinkieli espanja?
     - Ei, minä en puhu espanjaa. Brasiliassa me puhumme portugalia.
     - Ai niin, tietysti.
     - Missä sinä asut?
     - Asun Puistolassa. Se on Pohjois-Helsingissä. Menen kotiin bussilla numero 75.
     - Minun bussi on 250. Minä en asu Helsingissä vaan Espoossa.
     - Hei, nyt minun bussi tulee! Moi moi, nähdään huomenna!
       Entered on [2014-10-08 Wed 23:08]
*** Finnish                                                         :FINNISH:
    Kuka sinä olet  Minä olen Olga
    Kuinka vanha sinä olet Minä olen 23 vuotta vanha.
    Milloin kurssi on Kurssi on maanantaina ja keskiviikkona.
    Mikä päivä tänään on Tänään on maanantai.
    Mitä kieltä sinä puhut Minä puhun italiaa.

    Entered on [2014-11-08 Sat 22:09]
*** Some random stuff                                               :FINNISH:
    Miksi et osta jäätelöä ? Koska minä säästän rahaa.
    Missä te asutte ? Me asumme Suomessa.
    Mistä sinä olet kotoisin ? Olen kotoisin  Brasiliasta.
    Mihin tämä bussi menee ? Tämä bussi menee Helsinkiin.

    Entered on [2014-11-08 Sat 22:15]
*** Some random stuff                                               :FINNISH:
    täällä    Minä asun Helsingissä. Olen täällä kurssilla.
    tuolla    Katso, tuolla on Pedro!
    siellä    Mikko asuu Brasiliassa, siellä on nyt talvi.

    hyvä - huono
    kuuma - kylmä
    vaikea - helppo
    pieni - iso
    uusi - vanha
    kaunis - ruma
    lämmin - viileä
    valoisa - pimeä
    paljon - vähän
    Entered on [2014-11-09 Sun 18:51]
*** Some random stuff                                               :FINNISH:
    1 jäätelö
    6 jäätelöä
    1 pitkä mies
    9 pitkää miestä
    1 hyvä tietokone
    3 hyvää tietokonetta

    Julia puhuu saksaa
    Minä rakastan Lauraa
    Olga eitsii työpaikkaa
    Pedro soittaa kitaraa
    Me kastomme televisiota
    Ymmärrätkö englantia
    Voitko auttaa minua

    Minulla ei ole autoa
    Pedrolla ei ole kissaa
     
    Entered on [2014-11-19 Wed 21:56]
*** Finnishpod101 ABS1L8                                            :FINNISH:

    - Dialog

      J: Tiedätkö, missä sininen mukini on?

      H: Se on keittiössä.

      J: Missä päin?

      H: Kuivauskaapissa.

      J: Siinähän se on. Kiitos.

      H: Eipä kestä.

    - Vocabulary

      | Finnish               | English                    | Class  |
      |-----------------------+----------------------------+--------|
      | eipä kestä            | you're welcome             | phrase |
      | siinä                 | there                      | adverb |
      | kaappi                | cabinet                    | noun   |
      | (astian)kuivauskaappi | (dish) drying cabinet      | noun   |
      | päin                  | in the approximate area of | adverb |
      | sininen               | blue                       | adj    |
      | muki                  | mug                        | n      |
      | tietää                | to known                   | v      |
      | missä                 | where                      | adv    |
      | keittiö               | kitchen                    | n      | 

    - Sample sentences

      | Finnish                            | English                              |
      | Eipä kestä, ei siitä ollut vaivaa. | Don't mention it, it was no trouble. |
      | Siinä se on.                       | There it is.                         |
      | Kuivauskaappi on täynnä.           | The drying cabinet is full.          |
      | Missä päin asut?                   | Whereabouts do you live?             |
      | Taivas on sininen.                 | The sky is blue.                     |
      | Muki on kaapissa.                  | The mug is in the cabinet.           |
      | Missä olet?                        | Where are you?                       |
      | Missä on johtaja?                  | Where is the boss?                   | 

    - Grammer

      - Words with only one stem

        | Nominative | Partitive  | Inessive          | English     |
        |------------+------------+-------------------+-------------|
        | päivä      | päivä-ä    | päivä-ssä         | day         |
        | hyvä       | hyvä-ä     | hyvä-ssä          | good        |
        | minä       | minu-a     | minu-ssa          | I           |
        | hauska     | hauska-a   | hauska-ssa        | fun, nice   |
        | terve      | terve-ttä  | tervee-ssä        | healthy     |
        | sinä       | sinu-a     | sinu-ssa          | you         |
        | mikä       | mi-tä      | mi-ssä            | what, which |
        | tämä       | tä-tä      | tä-ssä            | this        |
        | se         | si-tä      | sii-nä(irregular) | it          |
        | tuo        | tuo-ta     | tuo-ssa           | that        |
        | lasi       | lasi-a     | lasi-ssa          | glass       |
        | suola      | suola-a    | suola-ssa         | salt        |
        | sokeri     | sokeri-a   | sokeri-ssa        | sugar       |
        | tee        | tee-tä     | tee-ssä           | tea         |
        | itse       | itse-ä     | itse-ssä          | self        |
        | koulu      | koulu-a    | koulu-ssa         | school      |
        | maito      | maito-a    | maido-ssa         | milk        |
        | salaatti   | salaatti-a | salaati-ssa       | salad       |
        | omena      | omena-a    | omena-ssa         | apple       |
        | päärynä    | päärynä-ä  | päärynä-ssä       | pear        |
        | piirakka   | piirakka-a | piiraka-ssa       | pie         |
        | mustikka   | mustikka-a | mustika-ssa       | blueberry   |
        | vihreä     | vihreä-ä   | vihreä-ssä        | green       |
        | musta      | musta-a    | musta-ssa         | black       |
        | kahvi      | kahvi-a    | kahvi-ssa         | coffee      |
        | muki       | muki-a     | muki-ssa          | cup         |
        | keittiö    | keittiö-tä | keittiö-ssä       | kitchen     |
        | kaappi     | kaappi-a   | kaapi-ssa         | cupboard    |
        |            |            |                   |             |

      - Words with two stems

	  | Nominative  | Partitive    | Inessive       | English   |
	  |-------------+--------------+----------------+-----------|
	  | väsynyt     | väsynyt-tä   | väsynee-ssä    | tired     |
	  | hän         | hän-tä       | häne-ssä       | he/she    |
	  | lautanen    | lautas-ta    | lautase-ssa    | plate     |
	  | kuka        | ke-tä        | kene-ssä       | who       |
	  | kiitos      | kiitos-ta    | kiitokse-ssa   | thank     |
	  | herkullinen | herkullis-ta | herkullise-ssa | delicious |
	  | sininen     | sinis-tä     | sinise-ssä     | blue      | 

    - Usage

	  The basic meaning of the inessive is "in"; that is, you are saying that there is something inside the thing that is in the inessive case.
	 
	  For example:
	 
    1. Lasi on kaapissa.
       "/The glass is in the cabinet./"

    2. Mitä tuossa sinisessä mukissa on?
       "/What's in that blue mug?/"

    3. Tässä piirakassa on omenaa ja päärynää.
       "/There's apple and pear in this pie./"

    4. Missä kaapissa lautanen on?
       "/Which cabinet is the plate in?/"

	  Vague locative meaning. Used with month names to indicate that an action takes place during that month, or something takes place at regular intervals.
	 
	  For example:
	 
    1. Liisa on puhelimessa.
       "/Liisa is on the phone./"

    2. Minussa ei ole mitään vikaa.
       "/There's nothing wrong with me./"

    3. Heinäkuussa poimin mustikoita.
       "/In July, I pick blueberries./"

    4. Omena päivässä pitää lääkärin loitolla.
       "/An apple a day keeps the doctor away./"

	  Ongoing action.

	  For example:

    1. Olen juuri syömässä.
       "/I am eating just now./"

    2. Olen jo menossa.
       "/I am on my way./"

	  Lastly, it can be found in certain expressions of state.
	 
	  For example:

    1. Leipä on homeessa. (home = "mould")
       "/The bread is mouldy./"

    2. Ville on humalassa. (humala = "state of drunkenness")
       "/Ville is drunk./"

       :LOGBOOK:
       CLOCK: [2015-09-18 Fri 21:26]--[2015-09-18 Fri 21:37] =>  0:11
       :END:
    [2015-09-18 Fri 21:26]

*** Finnishpod101 ABS1L9                                            :FINNISH:
**** Conversation  

     H: Kuka tämä on?

     E: Se on isoäiti. Isoäidin vieressä on isän veli.

     H: Kuka tuo on?

     E: Se on isän sisko.

     H: Entä tuo?

     E: Se on Lauri, isän siskon poika.

**** Vocabulary

     | Finnish  | English     | Class |
     |----------+-------------+-------|
     | poika    | son; boy    | n     |
     | äiti     | mother      | n     |
     | vieressä | next to     | adv   |
     | sisko    | sister      | n     |
     | isoäiti  | grandmother | n     |
     | iso      | big         | adj   |
     | isä      | father      | n     |
     | veli     | brother     | n     | 

**** Sample sentences  
   
     |-------------------------------------+------------------------------------|
     | Tuo poika ostaa jäätelöä.           | That boy buys some ice cream.      |
     | Kallen poika ui hyvin.              | Kalle's son swims well.            |
     | Äiti on puhelimessa.                | Mother is on the phone.            |
     | Äiti luki tyttärelleen.             | The mother read to her daughter.   |
     | Jussi istuu Emmin vieressä.         | Jussi is sitting next to Emmi      |
     | Jussin sisko on koulussa.           | Jussi's sister is at school.       |
     | Minulla on sisko.                   | I have a sister.                   |
     | Isoäiti tekee hyvää omenapiirakkaa. | Grandma makes good apple pie.      |
     | Tiinan koira on iso.                | Tiina's dog is big                 |
     | Juusin isä on taksinkuljettaja.     | Juusi's father is a taxi driver.   |
     | Isä palaa kotiin.                   | The father returns home            |
     | Emmin veli on Jussi.                | Emmi's brother is Jussi.           |
     | Veljekset käyvät kylvyssä illalla.  | The brothers bathe in the evening. |
   
**** Vocabulary phrase usage
***** ...n vieressä ("next to...")
***** isoäiti and other family terms
      | Finnish     | English          |
      | tytär       | daughter         |
      | pikkusisko  | little sister    |
      | pikkuveli   | little brother   |
      | setä        | father's brother |
      | eno         | mother's brother |
      | täti        | aunt             |
      | serkku      | cousin           |
      | lapsi       | child            |
      | lapsenlapsi | grandchild       |
      | vejenpoika  | nephew           |
      | veljentytär | niece            |
      | anoppi      | mother in law    |
      | appi        | father in law    |
      | miniä       | daughter in law  |
      | vävy        | son in law       |
      | äitipuoli   | stepmother       |

**** Grammar

***** Genitive cases

      | Nominative | Stem               | Genitive  | English |
      |------------+--------------------+-----------+---------|
      | muki       | muki-              | muki-n    | mug     |
      | isä        | isä-               | isä-n     | father  |
      | väsynyt    | väsynyt-, väsynee- | väsynee-n | tired   |
      | lautanen   | lautas-, lautase-  | lautase-n | plate   |
      | sininen    | sinis-, sinise-    | sinise-n  | blue    | 

***** k-p-t cases

      -kk, -pp, -tt becomes -k, -p, and -t

      | presidentti | presidenti- |
      | salaatti    | salaati-    |
      | piirakka    | piiraka-    |
      | kaappi      | kaapi-      |

***** -t becomes -d
      | äiti   | äidi-  |
      | maito  | maido- |
      | tietää | tiedä- | 

      For example:

      1. Jussin muki on astiankuivauskaapissa.
	    "/Jussi's mug is in the dish drying cabinet./"
      2. Helen katsoo Emmin serkun kuvaa.
	    "/Helen looks at the picture of Emmi's cousin./"
      3. Äidin kahvi on kuumaa.
	    "/Mother's coffee is hot./"
      4. Tämän vihreän lasin vieressä on sininen lautanen.
	    "/Next to shi green glass, there is a blue plate./"

      [2015-09-21 Mon 21:58]

*** Finnishpod101 ABS1L10                                           :FINNISH:
**** Conversation
     
     E: Maiju, tässä on Helen.

     M: Hei!

     E: Hei! Minä olen australialainen.

     M: Oletko vaihto-oppilas?

     H: Kyllä. Käyn suomalaista koulua.

     M: Onko suomi vaikeaa?

     H: Se on kovin erilaista kuin englanti.

**** Vocabulary

     | Finnish         | English          | Class |
     |-----------------+------------------+-------|
     | käydä           | to go, to visit  | v     |
     | suomalainen     | Finnish          | adj   |
     | kovin           | very             | adv   |
     | australialainen | Australian       | adj   |
     | englantia       | English          | n     |
     | vaihto-oppilas  | exchange student | n     |
     | suomi           | Finnish          | n     |
     | vaikea          | difficult        | adj   |
     | erilainen       | different        | adj   |
     | kuin            | than             | conj  | 

**** Sample sentences

     | Finnish                                       | English                                   |
     |-----------------------------------------------+-------------------------------------------|
     | Haluan käydä joskus Keniassa.                 | I want to visit Kenya sometime.           |
     | Jari Litmanen on suomalainen jalkapalloilija. | Jari Litmanen is a Finnish soccer player. |
     | Onko tämä suomalaista olutta?                 | Is this Finnish beer?                     |
     | Kiina on kovin kaukana Suomesta.              | China is very far from Finland.           |
     | Kenguru on australialainen eläin.             | The kangaroo is an Australian animal.     |
     | Ville osaa puhua englantia.                   | Ville can speak English.                  |
     | Meillä on saksalainen vaihto-oppilas.         | We have a German exchange student.        |
     | Opiskeletko sinä suomea?                      | Do you study Finnish?                     |
     | Tämä lautanen on erilainen kuin tuo.          | This plate is different from that one.    |
     | Emmi on yhtä pitkä kuin Helen.                | Emmi on yhtä pitkä kuin Helen.            |
     | Meksiko on suurempi kuin Belize.              | Mexico is bigger then Belize.             |

*** Finnishpod101 ABS1L11                                           :FINNISH:
**** Conversation

     H: Millainen sää tänään on?
     
     J: En tiedä. Hetki, katson ennustetta.

     H: Tarvitsenko sateenvarjoa?

     J: Et tarvitse. Tänään ei sada.

     H: Hyvä. En kaipaa sadetta.

**** Vocabulary

     | Finnish     | English          |
     |-------------+------------------|
     | tänään      | today            |
     | hetki       | moment           |
     | sateenvarjo | umbrella         |
     | millainen   | what kind of     |
     | sää         | weather          |
     | katsoa      | look             |
     | ennuste     | forecast         |
     | sataa       | rain             |
     | kaivata     | to need, to miss | 

**** Sample sentences
     | Finnish                     | English                             |
     |-----------------------------+-------------------------------------|
     | Olen tänään kiireinen       | I'm busy today                      |
     | Hetki, tulen pian           | Just a moment, I'll come soon       |
     | Saisinko tuon sateenvarjon? | May I have that umbrella, please?   |
     | Millainen koulua Helen käy? | What kind of school does Helen go?  |
     | Sade alkaa aamulla.         | The rain will start in the morning. |
     | Sade putoaa kadulle.        | The rain is falling on the street.  |
     | Eilen oli hyvä sää.         | The weather was nice yesterday.     |
     | Maiju katsoo elokuvaa.      | Maiju is watching a movie.          |
     | Ennuste ei lupaa hyvää.     | The forecase doesn't promise well.  |
     | En mene ulos, siellä sataa. | I'm not going out, it's raining     |
     | En kaipaa neuvoja           | I don't want any advice.            |

*** Finnishpod101 ABS1L12
**** Conversation
     E: Mitä sinä harrastat?

     H: Soitan kitaraa ja uin. Entä sinä?

     E: Minä pelaan sählya. Minä myös luen paljon.

     H: Muuten, vieläkö luet tuota kirjaa?

     E: En, luin sen jo.

**** Vocabulary

     | Finnish   | English              |
     |-----------+----------------------|
     | kitara    | guitar               |
     | uida      | swim                 |
     | lukea     | to read              |
     | harrastaa | to do as a hobby     |
     | kirja     | book                 |
     | soittaa   | to play (instrument) |
     | pelata    | to play (sports)     |
     | sähly     | floorball            |
     | paljon    | much, many           |
     | muuten    | by the way           |

**** Sample sentances

     | Finnish                               | English                                     |
     |---------------------------------------+---------------------------------------------|
     | Ostan ensi vuonna uuden kitaran       | I will buy a new guitar next year           |
     | Monet rockmuusikot soittavat kitaraa. | Many rock musicians play the guitar         |
     | Uin kilometrin joka lauantai.         | I swim one kilometer every Saturday         |
     | Nainen ui altaassa.                   | The woman is swimming in the pool.          |
     | Lähettäjän nimi lukee paketissa.      | The sender's name is stated on the package. |
     | Isä lukee lehden aamulla.             | Dad reads the newspaper in the morning      |

*** Finnishpod101 ABS1l13
**** Conversation

     E: Tule jo!
    
     H: Odota vähän, puen vain takin.

     E: Jussi, anna tuo kirja.

     J: Ole hyvä.

     E: Kiitos.

     J: Älä unohda huhelinta.

**** Vocabulary
     | Finnish | English           |
     |---------+-------------------|
     | odottaa | to wait           |
     | vähän   | a bit             |
     | takki   | jacket, coat      |
     | tulla   | to come           |
     | puhelin | telephone         |
     | jo      | already           |
     | pukea   | to put on clothes |
     | vain    | only just         |
     | antaa   | to give           |
     | unohtaa | to forget         |

**** Sample sentences

     | Finnish                 | English                    |
     |-------------------------+----------------------------|
     | Odotan sinua puistossa. | I wil wait you in the park |
     | Saisinko vähän teetä?   | May I have a little tea?   |
     | Onko tämä takki lämmin? | Is this coat warm?         |
     | Tuo puhelin ei toimi.   | That phone doesn't work    |
     | Tulen huomenna.         | I will come tomorrow.      |

*** Finnishpod101 ABS1l14
**** Conversation

     L: Helen, auttaisitko vähän?
     
     H: Totta kai.
     
     L: Pese salaatti ja laita se kulhoon.
     
     H: Selvä.
     
     L: Laita kala uuniin ja pasta kattilaan.
     
     H: OK.

**** Vocabulary

     | Finnish    | English                 |
     |------------+-------------------------|
     | laittaa    | to put, to prepare food |
     | kulho      | bowl                    |
     | uuni       | oven                    |
     | auttaa     | to help                 |
     | pestä      | to wash                 |
     | selvä      | all right               |
     | OK (ookoo) | OK                      |

**** Sample sentances

     | Finnish                               | English                           |
     |---------------------------------------+-----------------------------------|
     | Laita kattila tuohon.                 | Put the stockpot there            |
     | Onko uuni jo kuuma?                   | Is the oven hot already?          |
     | Laitan salaatin yleensä tähän kulhoon | I usually put salad in this bowl. |
     | Voinko auttaa?                        | May I help you?                   |
     | OK, tulen ihan pian.                  | OK, I will come in a minute.      |
     | Menen nyt syömään.                    | I am off to eat now.              |

*** Finnishpod101 ABS1l15
**** Conversation
     L: Kala on valmis. Ota se pois uunista.
     
     H: Selvä.

     L: kaada pastakattilasta vesi pois.

     H: Selvä.

     L: Ota maito ja voi jääkaapista. Hae sitten Emmi ja Jussi yläkerrasta.
**** Vocabulary

     | en        | fi                    |
     |-----------+-----------------------|
     | jääkaappi | fridge                |
     | voi       | butter                |
     | sitten    | then                  |
     | hakea     | to fetch, to pick up  |
     | yläkerta  | upstairs              |
     | vesi      | water                 |
     | pois      | away, off             |
     | kaataa    | to pour, to turn over |

**** Sample sentences
     | fi                                   | en                                                 |
     |--------------------------------------+----------------------------------------------------|
     | Ota salaatti jääkaapista.            | Take the saland from the fridge.                   |
     | Voi on kovaa.                        | The butter is hard.                                |
     | Käy kaupassa ja laita sitten ruokaa. | Go to the grocery store and then prepare the meal. |
     | Haenko Kaisan koulusta?              | Shall I pick up Kaisa from school?                 |
     | Emmi on yläkerrassa.                 | Emmi is upstairs.                                  |
     | Vesi on kylmää.                      | The water is cold.                                 |
     | Nainen juo vettä.                    | The woman drinks water.                            |
     | Mene pois!                           | Go away!                                           |
*** FinnishPod101 ABS1l16
**** Conversation
     J: Haenko videovuokraamosta jonkin elokuvan?

     E: Hyvä ajatus. Minä käyn samalla kirjastossa.

     J: Helen, tuletko mukaan videovuokraamoon ja kirjastoon?

     H: Mielelläni.

**** Vocabulary
     | fi             | en                                |
     |----------------+-----------------------------------|
     | mukaan         | along                             |
     | mielelläni     | I'd love to                       |
     | elokuva        | movie                             |
     | ajatus         | thought, idea                     |
     | videovuokraamo | video rental store                |
     | jokin          | some                              |
     | samalla        | on the same way, at the same time |
     | kirjasto       | bookstore                         |

**** Sample sentances
     | fi                                 | en                                          |
     |------------------------------------+---------------------------------------------|
     | Tuletko mukaan elokuviin?          | Would you like to come along to the movies? |
     | Katsoisin mielelläni tuon elokuvan | I would like to watch that movie            |
     | Sehän on loistava ajatus!          | That's a brilliant idea                     |
     | Etsitkö jotakin?                   | Are you looking for something?              |
     | Tuletko mukaan kauppaan?           | Will you come along to the store?           |
     | Tuletko mukaan puistoon?           | Will you come along to the park?            |

*** FinnishPod101 ABS1l17
**** Conversation
     E: Mitä sanot tästä?

     J: Minä en pidä romantiikasta. Minä pidän enemmän toiminnasta.

     H: Minä pidän komediasta.

     E: Entä käykö tämä sitten?

     H: se sopii hyvin.

     J: Kelpaa.
**** Vocabulary

     | fi          | en                |
     |-------------+-------------------|
     | romantiikka | romance           |
     | enemmän     | more              |
     | toiminta    | action, activity  |
     | komedia     | comedy            |
     | sopia       | to suit to fit    |
     | kelvata     | to be good enough |
     | sanoa       | to say            |
     | pitää       | to like           |

**** Sample sentences
     | fi                                        | en                                   |
     |-------------------------------------------+--------------------------------------|
     | Minä pidän romantiikasta                  | I like romance                       |
     | Pidätkö enemmän sählystä vai jääkiekosta? | Do you prefer floorball or ice hocky |
     | Tämä on loistava komedia                  | This is a brilliant comedy           |
     | Älä sano mitään                           | Don't say anything                   |
     | Pidätkö mustasta kahvista?                | Do you like black coffee             |
     | Minä en pidä tästä elokuvasta             | I don't like this movie              |
     | Minä pidän Tomista                        | I like Tomi                          |
     | Jussi pitää toiminnasta                   | Jussi likes action                   |
     | Mistä Emmi pitää?                         | What does Emmi like                  |

*** FinnishPod101 ABS118
**** Conversation
     E: Onko kaikki valmista?

     H: Karkkipussi on pöydällä.

     E: Missä DVD on?

     H: Tuolilla.

     E: Entä kaukosäädin?

     H: Se on sohvalla.
**** Vocabulary

     | fi          | en                |
     |-------------+-------------------|
     | tuoli       | chair             |
     | kaukosäädin | remote controller |
     | sohva       | sofa              |
     | pussi       | bag               |
     | pöytä       | table             |
     | kaikki      | everything        |

**** Sample Sentences
     | fi                               | en                              |
     |----------------------------------+---------------------------------|
     | Vuokraan tämän DVD:n             | I'll rent this DVD              |
     | Jussi istuu tuolilla             | Jussi is sitting on the chair   |
     | Haluaisin pussin karkkia, kiitos | I'd like a bag of candy please  |
     | Kukkamaljakko on pöydällä.       | The flower vase is on the table |
     | En pidä tästä pöydästä.          | I don't like this table         |
     | Ymmärrätkö kaiken?               | Do you understand everything?   |

*** FinnishPod101 ABS119
**** Conversation
     E: Onko sinulla yhtään veljeä tai siskoa?

     H: Minulla on yksi sisko.

     E: Onko hän saman näköinen kuin sinä?

     H: Jonkin verran, mutta minulla on ruskeat hiukset ja hänellä punaiset. Hänellä on myös vihreät silmät.

**** Vocabulary

     | fi            | en                                            |
     |---------------+-----------------------------------------------|
     | sama          | same                                          |
     | näköinen      | looking                                       |
     | ruskea        | brown                                         |
     | yhtään        | any (used in questions or negative sentences) |
     | silmä         | eye                                           |
     | yksi          | one                                           |
     | kuin          | than                                          |
     | jonkin verran | somewhat                                      |
     | hius          | hair                                          |
     | punainen      | red                                           |

**** Sample sentences
     | fi                                       | en                                    |
     |------------------------------------------+---------------------------------------|
     | Onko tämä väri sama kuin tuo?            | Is this color the same as that one?   |
     | Liisa on iloisen näköinen.               | Liisa looks happy                     |
     | Emmi käyttää ruskeaa takkia.             | Minulla ei ole yhtään rahaa.          |
     | Minulla on siniset silmät.               | I have blue eyes                      |
     | Minulla on yksi omena.                   | I have one apple                      |
     | Kulhossa on vielä jonkin verran sokeria. | There's still some sugar in the bowl. |
     | Kyllä, puhun jonkin verran.              | Yes, I speak somewhat.                |
     | Petrillä on mustat hiukset.              | Perti has black hair.                 |
*** FinnishPod101 ABS1120
**** Conversation
     E: Onko sinulla mitään eläimiä?

     H: Ei, mutta siskolla on akvaariokaloja. Ja isoisällä on koiria.

     E: Millaisia koiria hänellä on?

     H: Sekarotuisia ja todella suloisia.

**** Vocabulary
     | fi           | en                                             |
     |--------------+------------------------------------------------|
     | sekarotuinen | mixed-breed                                    |
     | rotu         | breed, race                                    |
     | todella      | really                                         |
     | suloinen     | cute                                           |
     | akvaariokala | aquarium fish                                  |
     | koira        | dog                                            |
     | mitään       | any, anything, nothing (in negative sentences) |
     | eläin        | animal                                         |

**** Sample sentences
     | fi                                | en                      |
     |-----------------------------------+-------------------------|
     | Tuo koira on sekarotuinen         | Tha dog is mixd-breed   |
     | Hänellä on todella tummat hiukset | He has really dark hair |
     | Minä rakastan koiria              | I love dogs             |
     | En tarvitse mitään                | I don't need anything   |

     | partitive singular | partitive plural | English      |
     |--------------------+------------------+--------------|
     | eläin-tä           | eläim-i-ä        | animal       |
     | kala-a             | kalo-j-a         | fish         |
     | koira-a            | koir-i-a         | dog          |
     | millais-ta         | millais-i-a      | what kind of |
     | sulois-ta          | sulois-i-a       | cute         |
     | lasi-a             | lase-j-a         | glass        |
     | kaappi-a           | kaappe-j-a       | cabinet      |
*** Finntastic Spoken Finnish
    https://finntastic.teachable.com
    [2020-05-25 ma 00:02]
**** Basic Finnish Phrases
     Nice to meet you! = hauska tavata!

     Welcome! = tervetuloa! 

     Long time no see! = pitkästä aikaa!

     Cheers! = kippis!

     Excuse me/sorry = anteeks(I)

     Thanks! = kiitos!/kiitti!



     No problem! = ole hyvä / ei(pä) kestä! / eipä mitään!

     Here you are = ole hyvä

     Let’s go! = mennään! / läh(d)etään!

     Good luck! = onnea! / tsemppiä!

     Yes/yea = kyllä/joo.

     No = ei.



     Can you say that again, please? = voitko/voikko sanoa (sen) uudelleen?

     Can you speak a bit slower? = voitko/voikko puhua hieman hitaammin?

     How is this said Finnish? = miten tää sanotaan suomeks(I)? 

     I speak a bit of Finnish. = puhun vähän suomee/suomea. 

     Don’t know. = en tiiä/en tiedä. 
**** Saying Hello Bye
     Moi

     Moikka

     Moro (tampere)

     Terve



     Morjesta (guys)

     Morjes (guys)

     Heippa (a bit childish)

     Huomenta = good morning



     Päivää = good day / hello (a bit formal)

     Iltaa = good evening (a bit formal)

     Hyvää huomenta/päivää/iltaa  more formal

     Hyvää = good



     Moi moi! = bye bye!

     Nähdään! = see you!

     Moikka = bye!

     Morjes! (guys)

     Note the pitch, similar to English
**** Saying How Are You
     Questions:

     Mitä(s) kuuluu? = how are you?
     Miten/mites menee? = how’s it going?
     Kuis hurisee? = what’s up?
     Mitäs lauri? = what’s up lauri?
     Mitä(s) mies? = what’s up man? (guys often say this)
     There are more colloquial ways to say this.
     Replies:

     Kiitos hyvää/hyvin = thanks I’m good
     Ihan hyvää/hyvin = pretty good
     Ihan jees = pretty good
     Eipä kummempia = not bad
     Ihan ok (ookoo) = I’m ok 
     
     Return the question:

     Entä sulle? = how about you?

     Entä sä? = how about you?

     Mites sä? = what about you?

     Note the (grammatically correct) reply:

     Mitä kuuluu? ==> hyvää
     Miten menee? ==> hyvin
     More replies:

     Entä sulle? = how about you?
     Entä sä? = how about you?
     Mites sä? = what about you?
**** BE word
     Mä oon = I am
     Sä oot = You are
     Se on = He/She/It is
     Me ollaan = We are
     Te ootte = You (p) are
     Ne on = They are

     Summary:

     In Finnish verbs conjugate in persons
     only one word for he/she: hän
     Hän (he/she) is used for people
     se (it)& is used for inanimate objects
     ne (they) can be used for both people & objects
     Important things to keep in mind for spoken Finnish

     Se is commonly used to refer to a person even if they are used for inanimate stuff in standard
     The verb in we (2nd person plural) form is used in its PASSIVE FORM (we are passive)
     Ex. me olemme (standard) vs. me ollaan (spoken)
     3rd person plural (they) is used in 3rd person singular form
     (ex. Ne ovat (standard) vs ne on (spoken)
*** Finntastic2
**** Verbs syödä & juoda
    |----------------------+-----------------------|
    | To Be                | TO EAT                |
    |----------------------+-----------------------|
    | OON = I AM           | SYÖN = I EAT          |
    | OOT = YOU ARE        | SYÖT = YOU EAT        |
    | ON = HE/SHE/IT IS    | SYÖ = HE/SHE/IT EATS  |
    | OLLAAN = WE ARE      | SYÖDÄÄN = WE EAT      |
    | OOTTE = YOU ARE (PL) | SYÖTTE = YOU EAT (PL) |
    | ON = THEY ARE        | SYÖ = THEY EAT        |
    |----------------------+-----------------------|

    Mitä sä yleensä syöt aamupalaks(i)?
    What do you usually eat for breakfast?

    Ruisleipää, jugurttia ja hedelmiä.
    Rye bread, yogurt and fruits.

    Mitä me syödään tänään?
    What do we eat today?

    Tänään me syödään lihakeittoa.
    Today we eat meat soup.

    Mitä ne syö?
    What are they eating?

    Ne syö sushia.
    They are eating sushi.

    |---------+------------------|
    | JUON    | I DRINK          |
    | JUOT    | YOU DRINK        |
    | JUO     | HE/SHE/IT DRINKS |
    | JUODAAN | WE DRINK         |
    | JUOTTE  | YOU DRINK (PL)   |
    | JUO     | THEY DRINK       |
    |---------+------------------|

    Juokko/juotko/juoks vettä?
    Do you drink water?

    Taas nuo juo kaljaa.
    Again they are drinking beer.

    Salla juo aina punaviiniä.
    Salla always drinks red wine.
**** Verbs harrastaa & opiskella
     | HARRASTAN    |
     | HARRASTAT    |
     | HARRASTAA    |
     | HARRASTETAAN |
     | HARRASTATTE  |
     | HARRASTAA    |

     Miten paljon harrastatte liikuntaa?
     How much do you do sports?

     Mitä sä harrastat?
     What do you do as hobby?

     Harrastan pesäpalloa ja pyöräilyä.
     My hobbies are Finnish baseball and cycling.

     | OPISKELEN   |
     | OPISKELET   |
     | OPISKELEE   |
     | OPISKELLAAN |
     | OPISKELETTE |
     | OPISKELEE   |

     Mitä sä opiskelet yliopistossa?
     What do you study at university?

     Sähkötekniikkaa.
     Electrical engineering.

     Miks(i) sä opiskelet koko ajan?
     Why are you studing all the time?

     Koska me opiskellaan suomea yhdessä?
     When do we study Finnish together?
**** Verbs tulla & mennä
     | MEEN    |
     | MEET    |
     | MENEE   |
     | MENNÄÄN |
     | MEETTE  |
     | MENEE   |

     Mihin te meette?
     Where are you going?

     Meetkö tänään ulos?
     Are you going out today?

     Me mennään tänään baariin.
     We will go to a bar today.

     Jesse menee huomenna kauppaan.
     Jesse is going to do groceries tomorrow.

     | TUUN     |
     | TUUT     |
     | TULEE    |
     | TULLLAAN |
     | TUUTTE   |
     | TULEE    |

     Koska tuut?
     When do you come?

     Mihin me tullaan?
     Where do we come?

     Tuutteko tänään baariin?
     Do you come to bar today?

     Me tullaan ylihuomenna helsinkiin.
     We are coming to Helsinki the day after tomorrow.

     Me mennään rannalle.
     We go to beach.

     Jesse tulee meille.
     Jesse is coming to my place.
**** Verbs nähdä & tehdä
     näh(d)ä = to see, to meet
     | NÄÄN      |
     | NÄÄT      |
     | NÄKEE     |
     | NÄH(D)ÄÄN |
     | NÄÄTTE    |
     | NÄKEE     |

     Mä nään Jessen/Jesseä huomenna.
     I will meet Jesse tomorrow.

     Näh(d)äänkö huomenna?
     Let's meet tomorrow?

     Näätkö tuon auton?
     Can you see that car?

     Näätkö tuon miehen?
     Do you see that guy?

     Missä te näätte huomenna?
     Where do you meet tomorrow?

     tehdä = to do, to make

     | TEEN    |
     | TEET    |
     | TEKEE   |
     | TEHDÄÄN |
     | TEETTE  |
     | TEKEE   |

     Teen töitä joka päivä paitsi viikonloppuisin.
     I work every day except on weekends.

     Teen ruokaa joskus itse.
     I sometimes cook myself.

     Me tehdään uutta videota.
     We are making a new video.

     Mitä teet tänään?
     What do you do today?

     Teh(d)äänkö me ruokaa viikonloppuna?
     Will we cook on weekends?
**** Verbs tykätä & haluta
     tykätä = to like

     | TYKKÄÄN   |
     | TYKKÄÄT   |
     | TYKKÄÄ    |
     | TYKÄTÄÄN  |
     | TYKKÄÄTTE |
     | TYKKÄÄ    |

     Jussi tykkää Petrasta.
     Jussi likes Petra.

     Mä tykkään tenniksestä.
     I like tennis.

     Tykkään pelata tennistä.
     I like to play tennis.

* Android
** [20/20] Android Multithreading Masterclass
   - [X] Memory Leaks in Android
   - [X] Thread termination
     - Thread termination strategies:
       1. Return from ~run~ after successful execution
       2. Return from ~run~ in response to internal error
       3. Return from ~run~ in response to externally set flags
       4. Return from ~run~ in response to interruption (not recommended, favor 3)
   - [X] UI thread vs background thread in Android
   - [X] Demonstration of UI thread
   - [X] User interface responsiveness
   - [X] Protection of User Interface from Background threads
   - [X] Execution of the code on UI thread
   - [X] Handler and Looper Intuiation
     Only use handler and looper to access UI thread
   - [X] Introduction to multithreading challenges
   - [X] Visibility
   - [X] Atomicity
   - [X] Volatile variables
   - [X] Atomic Classes
   - [X] Threads Synchronization
   - [X] Immutability
   - [X] Happens Before
     +https://docs.oracle.com/javase/specs/jls/se7/html/jls-17.html+ this is not readable at all
   - [X] Happens Before Demonstration
   - [X] Exercise 4
   - [X] Exercise 4 Solution
   - [X] Exercise 4 solution amendament

** TODO [35/93] CustomView bilibili course
   - [X] 高级面试题讲解-1.flv
   - [X] 设计模式（责任链模式）-1.flv
   - [X] 自定义属性的一些细节-1.flv
   - [X] 昨日内容回顾-1.flv
   - [X] onMeasure()实战测量-1.flv
   - [X] onDraw()方法基线计算-1.flv
   - [X] 高级面试题讲解-1.flv
   - [X] 效果实现思路分析-1.flv
   - [X] 绘制最外层的大圆弧-1.flv
   - [X] 功能效果完善-1.flv
   - [X] 功能测试及动画加载-1.flv
   - [X] invalidate()源码分析-1.flv
   - [X] WX朋友圈过度渲染优化-1.flv
   - [X] 字体变色效果分析-1.flv
   - [X] 实现一个文字两种颜色-1.flv
   - [X] 增加不同朝向的方法-1.flv
   - [X] 下周任务布置-1.flv
   +- [ ] 打造炫酷的进度条-（效果实现分析）-1.flv+
   +- [ ] 打造炫酷的进度条-（画进度内圆）-1.flv+
   +- [ ] 打造炫酷的进度条-（画外圆弧和文字）-1.flv+
   +- [ ] 打造炫酷的进度条-（最后的测试）-1.flv++
   - [X] 仿58同城数据加载-（形状切换效果实现）-1.flv
   - [X] 效果实现分析-1.flv
   - [X] 初始化显示评分控件-1.flv
   - [X] 触摸交互和内存优化-1.flv
   - [X] onTouch()源码分析-1.flv
   - [X] 效果实现分析
   - [X] 绘制26个字母-1.flv
   - [X] 接口回掉和优化-1.flv
   - [X] 面试题介绍-1.flv
   - [X] WindowManagerImpl绘制流程入口-1.flv
   - [X] 第一步measure()源码分析-1.flv
   - [X] View的绘制流程-1.flv
   - [X] 根据源码思考和优化-1.flv
   - [X] onMeausre()测量和onLayout()摆放-1.flv
   - [X] 最后的测试和任务布置-1.flv
   - [X] Adapter设计模式讲解-1.flv
   - [X] 自定义View和ViewGroup的套路总结-1.flv
   - [X] View的Touch事件分发-1.flv
   - [ ] 事件拦截作业讲解-1.flv
   - [ ] View绘制流程回顾-1.flv
   - [ ] 实现QQ6.0侧滑效果-1.flv
   - [ ] ViewDragHelper使用介绍-1.flv
   - [ ] 列表菜单效果实现-1.flv
   - [ ] Touch事件分发实战-1.flv
   - [ ] 初始化九宫格显示-1.flv
   - [ ] 处理onTouch事件-1.flv
   - [ ] 绘制连线和箭头三角-1.flv
   - [ ] kotlin九宫格回顾-1.flv
   - [ ] 基本控件介绍-(RecyclerView，DrawerLayout)-1.flv
   - [ ] CoordinatorLayout和Behavior介绍-1.flv
   - [ ] 给状态栏设置颜色-1.flv
   - [ ] 设置状态栏为透明-1.flv
   - [ ] 昨日遗留问题解决-1.flv
   - [ ] CoordinatorLayout和Behavior介绍-1.flv
   - [ ] 自定义Behavior-1.flv
   - [ ] 视频项目介绍-1.flv
   - [ ] 系统架构和六大基本原则-1.flv
   - [ ] 侧滑拖动删除-1.flv
   - [ ] CoordinatorLayout源码分析-1.flv
   - [ ] Behavior的工作原理-1.flv
   - [ ] SnackBar源码分析-1.flv
   - [ ] 属性动画介绍-1.flv
   - [ ] 动画效果实现分析-1.flv
   - [ ] 性能优化-1.flv
   - [ ] 效果实现分析-1 (2).flv
   - [ ] Adapter设计模式适配-1.flv
   - [ ] 菜单动画实现-1.flv
   - [ ] 观察者设计模式讲解-1.flv
   - [ ] 花束直播加载动画分析和实现-1.flv
   - [ ] 绘制两个圆-1.flv
   - [ ] 贝塞尔曲线介绍-1.flv
   - [ ] 绘制贝塞尔曲线-1.flv
   - [ ] 效果演示和分析-1.flv
   - [ ] 整合贝塞尔曲线-1.flv
   - [ ] 消息回弹和爆炸-1.flv
   - [ ] 添加点赞图片-1.flv
   - [ ] 自定义贝塞尔Evaluator-1.flv
   - [ ] 确定贝塞尔的控制点-1.flv
   - [ ] 效果和性能优化-1.flv
   - [ ] 效果演示和分析
   - [ ] 拦截View的创建-1.flv
   - [ ] 解析自定义属性-1.flv
   - [ ] 监听滑动改变位置-1.flv
   - [ ] 效果分析和实现-1.flv
   - [ ] 实现旋转动画-1.flv
   - [ ] 实现聚合和扩散-1.flv
   - [ ] PhoneWindow的创建过程-1.flv
   - [ ] 布局的测量和绘制过程-1.flv
   - [ ] 窗口与WindowManagerService服务的连接过程-1.flv
   - [ ] 内存泄漏和内存抖动-1.flv
   - [ ] 自定义View代码优化-1.flv
   - [ ] UI渲染与界面卡顿-1.flv
   - [ ] 资源和布局适配-1.flv
   - [ ] 图片适配-1.flv
   - [ ] 适配进度条动画-1.flv
   - [ ] 实现爆炸扩散动画-1.flv
** TODO MotionLayout
   - [ ] Simple transition tutorial https://www.youtube.com/watch?v=T6029TkohgU&t=656s
** Navigation
*** Key parts
    - Navigation graph (xml)
    - NavHostFragment
    - NavController
*** Navigation graph
    Contains =Destinations=, and they are connected by arrows called =Actions=.
    =Destination= can be Fragment, Activity or something customized.
*** NavController
**** How to find NavController?
     Your =NavController= is associated with a =NavHostFragment=
     1. =Fragment.findNavController()=
     2. =View.findNavController()=
     3. =Activity.findNavController(viewId: Int)=
**** What can NavController do?
***** Navigate using =destination='s =id= (not recommended)
      =findNavController().navigate(R.id.some_destination_id)=
***** Navigate using =action=
      =navigate(@IdRes int action_id, @Nullable Bundle args)=
***** NavOptions
      When navigate using =NavController=, we can speicify a =NavOption=.
      All the options:
      #+BEGIN_SRC kotlin
        private boolean mSingleTop;
        private int mPopUpTo;
        private boolean mPopUpToInclusive;

        private int mEnterAnim;
        private int mExitAnim;
        private int mPopEnterAnim;
        private int mPopExitAnim;
      #+END_SRC

      If you are using =Destination=, these options can be specified inside the xml.

**** Using safe args for navigation
     =Safe args= is a gradle plugin.
**** Define =argument= in fragment
     #+BEGIN_SRC xml
       <fragment
           android:id="@+id/flow_step_one_dest"
           android:name="com.example.android.codelabs.navigation.FlowStepFragment"
           tools:layout="@layout/flow_step_one_fragment">
         <argument
             android:name="flowStepNumber"
             app:argType="integer"
             android:defaultValue="1" />

         <action
             android:id="@+id/next_action"
             app:destination="@+id/flow_step_two_dest" />
       </fragment>
     #+END_SRC
     This means: the =FlowStepFragment= expects an Integer argument =flowStepNumber=.
**** Get the argument in Fragment
     #+BEGIN_SRC kotlin
       val safeArgs: FlowStepFragmentArgs by navArgs()
       val flowStepNumber = safeArgs.flowStepNumber
     #+END_SRC
**** Navigate to the Fragment with argument
     Let's see how to navigate from =HomeFragment= to =FlowStepFragment=.

     This is =HomeFragment=:
     #+BEGIN_SRC xml
       <fragment
           android:id="@+id/home_dest"
           android:name="com.example.android.codelabs.navigation.HomeFragment"
           android:label="@string/home"
           tools:layout="@layout/home_fragment">

         <action
             android:id="@+id/next_action"
             app:destination="@id/flow_step_one_dest"
             app:enterAnim="@anim/slide_in_right"
             app:exitAnim="@anim/slide_out_left"
             app:popEnterAnim="@anim/slide_in_left"
             app:popExitAnim="@anim/slide_out_right" />
       </fragment>
     #+END_SRC

     Safe args will generate a class =HomeFragmentDirections= that contains all the specified =actions=.

     In this case, it knows that the =destination= of the =next_action= is =FlowStepFragment=, which requires a argument.
     So it generates a method =nextAction(Integer)= with one Integer argument.
     
     #+BEGIN_SRC kotlin
       val flowStepNumberArg = 1
       val action = HomeFragmentDirections.nextAction(flowStepNumberArg)
       findNavController().navigate(action)
     #+END_SRC
** TODO Blog posts
   - [ ] https://zsmb.co
* Programming Languages
** Clojure
*** Vectors as Stacks
    #+BEGIN_SRC clojure
      (def stack [1 2 3 4])
      (peek stack)   ;; peek
      (pop stack)    ;; pop
      (conj stack 5) ;; push
    #+END_SRC

    #+BEGIN_SRC clojure
      (defn my-map [f coll]
        (loop [coll coll acc []]
          (if (empty? coll)
            acc
            (recur (next coll)
                   (conj acc (f (first coll)))))))
      (my-map #(+ % 1) [1 2 3 4])
    #+END_SRC


    #+RESULTS:
    : #'user/my-map[2 3 4 5]
*** Finding positions of items in a sequence
    #+BEGIN_SRC clojure
      (defn index [coll]
        (cond
          (map? coll) (seq coll)
          (set? coll) (map vector coll coll)
          :else (map vector (iterate inc 0) coll)))

      (defn pos [pred coll]
        (for [[i v] (index coll) :when (pred v)] i))
      (pos #(= % 3) [1 4 5 6 3 2 5 3 9 8 3])
      (pos #(= % 4) {:a 1 :b 2 :c 3 :d 4})
      (pos #(= % :k) #{:a :b :k :e})
    #+END_SRC

    #+RESULTS:
    : #'user/index#'user/pos(4 7 10)(:d)(:k)


    * Books
*** Higher Order Functions
    #+BEGIN_SRC clojure
      (def plays [{:band "Burial" :plays 979 :loved 9}
                  {:band "Eno" :plays 2333 :loved 15}
                  {:band "Bill Evans" :plays 979 :loved 9}
                  {:band "Magma" :plays 2665 :loved 31}])

    #+END_SRC

    #+RESULTS:
    : #'user/plays

    Sort by plays / loved ratio

    #+BEGIN_SRC clojure
      (sort-by #(/ (:plays %) (:loved %)) plays)
    #+END_SRC

    #+RESULTS:
    | :band | Magma      | :plays | 2665 | :loved | 31 |
    | :band | Burial     | :plays |  979 | :loved |  9 |
    | :band | Bill Evans | :plays |  979 | :loved |  9 |
    | :band | Eno        | :plays | 2333 | :loved | 15 |

** Kotlin
*** Higher order function
    Function type:
    #+BEGIN_SRC kotlin
      val sum: (Int, Int) -> Int = { a, b -> a + b }
      val action: () -> Unit = { println("hello") }
      action.invoke()
      sum(1, 2)
    #+END_SRC

    #+RESULTS:
    : hello
    : res0: kotlin.Int = 3
    : res1: kotlin.String = >>>                                                                                                                                 
    
    Passing function into function:
    #+BEGIN_SRC kotlin :results output
      fun String.filter(predicate: (Char) -> Boolean): String {
          val sb = StringBuilder()
          for (index in 0 until length) {
              val element = get(index)
              if (predicate(element)) sb.append(element)
          }
          return sb.toString()
      }
      println("ab1c".filter { it in 'a'..'z'})
    #+END_SRC

    #+RESULTS:
    : abc
    : res23: kotlin.String = >>> 
    
    Original version of =joinToString=:
    #+BEGIN_SRC kotlin
      fun <T> Collection<T>.joinToString(
          separator: String = ", ",
          prefix: String = "",
          postfix: String = ""
      ): String {
          val result = StringBuilder(prefix)
          for ((index, element) in this.withIndex()) {
              if (index > 0) result.append(separator)
              result.append(element)
          }
          result.append(postfix)
          return result.toString()
      }
      listOf(1, 2, 3).joinToString()
    #+END_SRC

    #+RESULTS:
    : res26: kotlin.String = 1, 2, 3
    : res27: kotlin.String = >>> 

    Version that controls how to convert each element to String:
    #+BEGIN_SRC kotlin
      fun <T> Collection<T>.joinToString(
          separator: String = ", ",
          prefix: String = "",
          postfix: String = "",
          transform: (T) -> String = { it.toString() }
      ): String {
          val result = StringBuilder(prefix)
          for ((index, element) in this.withIndex()) {
              if (index > 0) result.append(separator)
              result.append(transform(element))
          }
          result.append(postfix)
          return result.toString()
      }
      listOf(1, 2, 3).joinToString(transform={ "$it*" })
    #+END_SRC

    #+RESULTS:
    : res28: kotlin.String = 1*, 2*, 3*
    : res29: kotlin.String = >>> 
*** DSL
    #+BEGIN_SRC kotlin
      import java.time.*

      enum class Tense {
          AGO, FROM_NOW
      }

      infix fun Int.days(tense: Tense): LocalDateTime {
          return when(tense) {
              Tense.AGO -> LocalDateTime.now().minusDays(this.toLong())
              Tense.FROM_NOW -> LocalDateTime.now().plusDays(this.toLong())
              else -> LocalDateTime.now()
          }
      }

      println(2 days Tense.AGO)
      println(2 days Tense.FROM_NOW)
    #+END_SRC

    #+RESULTS:
    : 2020-06-25T16:04:21.315
    : 2020-06-29T16:04:21.315
    : res25: kotlin.String = >>> 


    #+BEGIN_SRC kotlin
      fun call(greet: String.(String) -> Unit) {
          "hello".greet("Guowei")
      }

      call { name -> println("$this $name") }
    #+END_SRC

    #+RESULTS:
    : hello Guowei
    : res3: kotlin.String = >>> 

    #+BEGIN_SRC kotlin
      "planning" meeting {
          start at 3..15
      }

      class Meeting(val name: String) {
          val start = this

          infix fun at(time: IntRange) {
              println("Starts at $time")
          }
      }

      infix fun String.meeting(block: Meeting.() -> Unit): Meeting {
          val meeting = Meeting(this)
          meeting.block()
          return meeting
      }
    #+END_SRC

    #+RESULTS:
    : res7: kotlin.String = >>> 

    #+BEGIN_SRC kotlin
      class Robot {
          val left = "left"
          val right = "right"
          val fast = "fast"

          infix fun turns(direction: String) {
              println("Turns $direction")
          }

          infix fun runs(speed: String) {
              println("Runs $speed")
          }
      }

      fun operate(block: Robot.(Robot) -> Unit) {
          val robot = Robot()
          robot.block(robot)
      }

      operate {
          it turns left
          it turns right
          it runs fast
      }

    #+END_SRC

    #+RESULTS:
    : Turns left
    : Turns right
    : Runs fast
    : res3: kotlin.String = >>> 

*** DSL Builder
    #+BEGIN_SRC kotlin
      @DslMarker annotation class PersonDSL


      data class Person(val name: String, val age: Int, val address: Address)
      data class Address(val postalCode: String, val city: String, val street: String)

      @PersonDSL
      class AddressBuilder {
          private var postalCode = ""
          private var city = ""
          private var street = ""

          fun postalCode(block: () -> String) {
              this.postalCode = block()
          }

          fun city(block: () -> String) {
              this.city = block()
          }

          fun street(block: () -> String) {
              this.street = block()
          }

          fun build(): Address {
              return Address(postalCode, city, street)
          }
      }

      fun address(block: AddressBuilder.() -> Unit): Address {
          return AddressBuilder().apply(block).build()
      }

      @PersonDSL
      class PersonBuilder {
          private var name = ""
          private var age = 0;
          private var address = Address("", "", "")

          fun name(block: () -> String) {
              this.name = block()
          }

          fun age(block: () -> Int) {
              this.age = block()
          }

          fun address(block: AddressBuilder.() -> Unit) {
              this.address = AddressBuilder().apply(block).build()
          }

          fun build(): Person {
              return Person(name, age, address)
          }
      }

      fun person(block: PersonBuilder.() -> Unit): Person {
          return PersonBuilder().apply(block).build()
      }


      val person = person {
          name { "Guowei Lv" }
          age { 18 }
          address {
              postalCode { "00890" }
              street { "Hamentie" }
              city { "Helsinki" }

          }
      }

      print(person)
    #+END_SRC

    #+RESULTS:
    : Person(name=Guowei Lv, age=18, address=Address(postalCode=00890, city=Helsinki, street=Hamentie))res9: kotlin.String = >>> 

*** Dagger2
    #+HEADERS: :classname HelloWorld 
    #+begin_src java  :results output :exports both
      public interface Provider<T> {
          T get();
      }

      public final class Foo {
          @Inject Foo() {}
      }

      @Generated
      public final class Foo_Factory implements Provider<Foo> {
          @Override Foo get() {
              return new Foo();
          }
      }

      final class Bar {
          @Inject Bar(Foo foo) {}
      }

      @Generated
      public final class Bar_Factory implements Provider<Bar> {
          private final Provider<Foo> fooProvider;

          public Bar_Factory(Provider<Foo> fooProvider) {
              this.fooProvider = fooProvider;
          }

          @Override Bar get() {
              return new Bar(fooProvider.get());
          }
      }

      final class Baz {
          static Baz create(Bar bar) {
              return /* */;
          }
      }

      @Module
      final class MyModule {
          @Provides static Baz provideBaz(Bar bar) {
              return Baz.create();
          }
      }

      @Generated
      public final class Baz_Factory implements Provider<Baz> {
          private final Provider<Bar> barProvider;

          public Baz_Factory(Provider<Bar> barProvider) {
              this.barProvider = barProvider;
          }

          @Override Baz get() {
              return MyModule.provideBaz(barProvider.get());
          }
      }

      @Component(modules = MyModule.class)
      interface MyComponent {
          Baz baz();
      }

      @Generated
      final class DaggerMyComponent implements MyComponent {
          private final Provider<Foo> fooProvider;
          private final Provider<Bar> barProvider;
          private final Provider<Baz> bazProvider;

          DaggerMyComponent() {
              this.fooProvider = new Foo_Factory();
              this.barProvider = new Bar_Factory(fooProvider);
              this.bazProvider = new Baz_Factory(barProvider);
          }

          @Override public Baz baz() {
              return bazProvider.get();
          }
      }
    #+end_src

    #+RESULTS:
    : Hello, World

** C++
*** C++ VIP
**** Project 10
     #+BEGIN_SRC cpp
       #include <iostream>
       #include <string>

       using namespace std;

       class Human {
       public:
         Human();
         Human(int age, int salary, string name);
         Human(const Human &other);
         void eat();
         void sleep();
         string getName();
         int getAge();
         int getSalary();

       private:
         string name;
         int age;
         int salary;
       };

       Human::Human() {
         name = "Anonymous";
         age = 0;
         salary = 0;
       }

       Human::Human(int age, int salary, string name) {
         this -> age = age;
         this -> salary = salary;
         this -> name = name;
       }

       // Copy constructor
       Human::Human(const Human &other) {
         cout << "Copy constructor called" << "\n";

         name = other.name;
         salary = other.salary;
         age = other.age;
       }

       void Human::eat() {
         cout << "Eating" << "\n";
       }

       void Human::sleep() {
         cout << "Sleeping" << "\n";
       }

       int Human::getAge() {
         return age;
       }

       string Human::getName() {
         return name;
       }

       int Human::getSalary() {
         return salary;
       }

       void showHuman(Human human) {
         cout << human.getName() << "\n";
       }

       int main(int argc, char *argv[])
       {
         Human h;
         cout << h.getName() << "\n";
         cout << h.getAge() << "\n";
         cout << h.getSalary() << "\n";

         Human h2(30, 1000, "Guowei");
         cout << h2.getName() << "\n";
         cout << h2.getAge() << "\n";
         cout << h2.getSalary() << "\n";

         Human h3 = h2;
         Human h4(h3);

         showHuman(h4);
         return 0;
       }
     #+END_SRC

     #+RESULTS:
     | Anonymous |             |        |
     | 0         |             |        |
     | 0         |             |        |
     | Guowei    |             |        |
     | 30        |             |        |
     | 1000      |             |        |
     | Copy      | constructor | called |
     | Copy      | constructor | called |
     | Copy      | constructor | called |
     | Guowei    |             |        |

* Programming Books
*** [3/3] Read GoF Design Patterns Cover to Cover
**** DONE Chapter 1
**** DONE Chapter 2
**** DONE Chapter 3
*** Land of Lisp
**** Text Advanture Game
***** Describing locations.
      #+BEGIN_SRC lisp :results raw
        (defparameter *nodes* '((living-room
                                 (you are in the living room. a wizard is snoring loudly on the couch.))
                                (garden
                                 (you are in the beautiful garden. there is a well in front of you.))
                                (attic
                                 (you are in the attic. there is a giant welding torch in the corner.))))
        (defun describe-location (location nodes)
          (cadr (assoc location nodes)))
      #+END_SRC

      #+RESULTS:
      DESCRIBE-LOCATION
      DESCRIBE-LOCATION
      DESCRIBE-LOCATION

      *nodes* is called association list, or /alist/ in short.
      #+BEGIN_SRC lisp :results raw
        (assoc 'garden *nodes*)
      #+END_SRC

      #+RESULTS:
      (GARDEN (YOU ARE IN THE BEAUTIFUL GARDEN. THERE IS A WELL IN FRONT OF YOU.))
      (GARDEN (YOU ARE IN THE BEAUTIFUL GARDEN. THERE IS A WELL IN FRONT OF YOU.))
      (GARDEN (YOU ARE IN THE BEAUTIFUL GARDEN. THERE IS A WELL IN FRONT OF YOU.))
***** Describing paths.
      #+BEGIN_SRC lisp :results raw
        (defparameter *edges* '((living-room
                                 (garden west door)
                                 (attic upstairs ladder))
                                (garden
                                 (living-room east door))
                                (attic
                                 (living-room downstairs ladder))))

        (defun describe-path (edge)
          `(there is a ,(caddr edge) going ,(cadr edge) from here.))

        (defun describe-paths (location edges)
          (apply #'append (mapcar #'describe-path (cdr (assoc location edges)))))

        (describe-paths 'living-room *edges*)
      #+END_SRC

      #+RESULTS:
      (THERE IS A DOOR GOING WEST FROM HERE. THERE IS A LADDER GOING UPSTAIRS FROM
       HERE.)
      (THERE IS A DOOR GOING WEST FROM HERE. THERE IS A LADDER GOING UPSTAIRS FROM
       HERE.)
      (THERE IS A DOOR GOING WEST FROM HERE. THERE IS A LADDER GOING UPSTAIRS FROM
       HERE.)
***** Describing Objects at Specific Location
      #+BEGIN_SRC lisp :results raw
        (defparameter *objects* '(whisky bucket frog chain))

        (defparameter *object-locations* '((whisky living-room)
                                           (bucket living-room)
                                           (chain garden)
                                           (frog garden)))

        (defun objects-at (loc objs obj-locs)
          (labels ((at-loc-p (obj)
                     (eq (cadr (assoc obj obj-locs)) loc)))
            (remove-if-not #'at-loc-p objs)))

        (objects-at 'living-room *objects* *object-locations*)
      #+END_SRC

      #+RESULTS:
      (WHISKY BUCKET)
      (WHISKY BUCKET)
      (WHISKY BUCKET)
***** Describing Visible Objects
      #+BEGIN_SRC lisp :results raw
        (defun describe-objects (loc objs obj-loc)
          (labels ((describe-obj (obj)
                     `(you see a ,obj on the floor.)))
            (apply #'append (mapcar #'describe-obj
                                    (objects-at loc objs obj-loc)))))

        (describe-objects 'living-room *objects* *object-locations*)
      #+END_SRC

      #+RESULTS:
      (YOU SEE A WHISKY ON THE FLOOR. YOU SEE A BUCKET ON THE FLOOR.)
      (YOU SEE A WHISKY ON THE FLOOR. YOU SEE A BUCKET ON THE FLOOR.)
      (YOU SEE A WHISKY ON THE FLOOR. YOU SEE A BUCKET ON THE FLOOR.)
***** Describing It All
      #+BEGIN_SRC lisp :results raw
        (defparameter *location* 'living-room)

        (defun look ()
          (append (describe-location *location* *nodes*)
                  (describe-paths *location* *edges*)
                  (describe-objects *location* *objects* *object-locations*)))

        (look)
      #+END_SRC

      #+RESULTS:
      (YOU ARE IN THE LIVING ROOM. A WIZARD IS SNORING LOUDLY ON THE COUCH. THERE IS
       A DOOR GOING WEST FROM HERE. THERE IS A LADDER GOING UPSTAIRS FROM HERE. YOU
       SEE A WHISKY ON THE FLOOR. YOU SEE A BUCKET ON THE FLOOR.)
      (YOU ARE IN THE LIVING ROOM. A WIZARD IS SNORING LOUDLY ON THE COUCH. THERE IS
       A DOOR GOING WEST FROM HERE. THERE IS A LADDER GOING UPSTAIRS FROM HERE. YOU
       SEE A WHISKY ON THE FLOOR. YOU SEE A BUCKET ON THE FLOOR.)
      (YOU ARE IN THE LIVING ROOM. A WIZARD IS SNORING LOUDLY ON THE COUCH. THERE IS
       A DOOR GOING WEST FROM HERE. THERE IS A LADDER GOING UPSTAIRS FROM HERE. YOU
       SEE A WHISKY ON THE FLOOR. YOU SEE A BUCKET ON THE FLOOR.)

       Walking Around in Our World
      #+BEGIN_SRC lisp :results raw
        (defun walk (direction)
          (let ((next (find direction
                            (cdr (assoc *location* *edges*))
                            :key #'cadr)))
            (if next
                (progn (setf *location* (car next))
                       (look))
                '(you cannot go that way.))))
      #+END_SRC

      #+RESULTS:
      WALK
      WALK
      WALK
***** Picking Up Objects
      #+BEGIN_SRC lisp :results raw
        (defun pickup (object)
          (cond ((member object
                         (objects-at *location* *objects* *object-locations*))
                 (push (list object 'body) *object-locations*)
                 `(you are now carrying the ,object))
                (t '(you cannot get that.))))
      #+END_SRC

      #+RESULTS:
      PICKUP
      PICKUP
      PICKUP
***** Checking Our Inventory
      #+BEGIN_SRC lisp :results raw
        (defun inventory ()
          (cons 'items- (objects-at 'body *objects* *object-locations*)))
      #+END_SRC

      #+RESULTS:
      INVENTORY
      INVENTORY
      INVENTORY
***** New Game Interface
      #+BEGIN_SRC lisp :results raw
        (defun game-read ()
          (let ((cmd (read-from-string
                      (concatenate 'string "(" (read-line) ")"))))
            (flet ((quote-it (x)
                     (list 'quote x)))
              (cons (car cmd) (mapcar #'quote-it (cdr cmd))))))

        (defparameter *allowed-commands* '(look walk pickup inventory))

        (defun game-eval (sexp)
          (if (member (car sexp) *allowed-commands*)
              (eval sexp)
              '(i do not know that command.)))

        (defun tweak-text (lst caps lit)
          (when lst
            (let ((item (car lst))
                  (rest (cdr lst)))
              (cond ((eq item #\space) (cons item (tweak-text rest caps lit)))
                    ((member item '(#\! #\? #\.)) (cons item (tweak-text rest t lit)))
                    ((eq item #\") (tweak-text rest caps (not lit)))
                    (lit (cons item (tweak-text nil lit)))
                    ((or caps lit) (cons (char-upcase item) (tweak-text rest nil lit)))
                    (t (cons (char-downcase item) (tweak-text rest nil nil)))))))

        (defun game-print (lst)
          (princ (coerce (tweak-text (coerce (string-trim "() "
                                                          (prin1-to-string lst))
                                             'list)
                                     t
                                     nil)
                         'string))
          (fresh-line))

        (defun game-repl ()
          (let ((cmd (game-read)))
            (unless (eq (car cmd) 'quit)
              (game-print (game-eval cmd))
              (game-repl))))
      #+END_SRC

      #+RESULTS:
      GAME-REPL
      GAME-REPL
      GAME-REPL

      #+BEGIN_SRC lisp :results raw
      #+END_SRC

      #+RESULTS:
      NIL
      NIL

      #+BEGIN_SRC lisp :results raw
      #+END_SRC

      #+RESULTS:
      NIL
      NIL

      #+BEGIN_SRC lisp :results raw
      #+END_SRC

      #+RESULTS:
      NIL
      NIL
**** Coding Beyond Basic Lists
*** SICP
**** Data-directed programming example: complex number system
***** Naive approach
****** Two representations of complex numbers
       1. As a pair of =real-part= and =imag-part=
       2. As a pair of =magnitude= and =angle=
****** Selectors and constructors of complex number
       #+BEGIN_SRC scheme
         ;; Selectors:
         (real-part z)
         (imag-part z)
         (magnitude z)
         (angle z)

         ;; Constructors
         (make-from-real-imag real imag)
         (make-from-mag-ang magnitude angle)
       #+END_SRC
****** Arithmetic operations on complex numbers based on the selectors and constructors
       #+NAME: operations
       #+BEGIN_SRC scheme
         (define (add-complex z1 z2)
           (make-from-real-imag (+ (real-part z1) (real-part z2))
                                (+ (imag-part z1) (imag-part z2))))

         (define (sub-complex z1 z2)
           (make-from-real-imag (- (real-part z1) (real-part z2))
                                (- (imag-part z1) (imag-part z2))))

         (define (mul-complex z1 z2)
           (make-from-mag-ang (* (magnitude z1) (magnitude z2))
                              (+ (angle z1) (angle z2))))

         (define (div-complex z1 z2)
           (make-from-mag-ang (/ (magnitude z1) (magnitude z2))
                              (- (angle z1) (angle z2))))
       #+END_SRC
****** Implementations of selectors that supports both representations
       #+NAME: selectors
       #+BEGIN_SRC scheme
         (define (real-part z)
           (cond ((rectangular? z) 
                  (real-part-rectangular (contents z)))
                 ((polar? z)
                  (real-part-polar (contents z)))
                 (else (error "Unknown type -- REAL-PART" z))))

         (define (imag-part z)
           (cond ((rectangular? z)
                  (imag-part-rectangular (contents z)))
                 ((polar? z)
                  (imag-part-polar (contents z)))
                 (else (error "Unknown type -- IMAG-PART" z))))

         (define (magnitude z)
           (cond ((rectangular? z)
                  (magnitude-rectangular (contents z)))
                 ((polar? z)
                  (magnitude-polar (contents z)))
                 (else (error "Unknown type -- MAGNITUDE" z))))

         (define (angle z)
           (cond ((rectangular? z)
                  (angle-rectangular (contents z)))
                 ((polar? z)
                  (angle-polar (contents z)))
                 (else (error "Unknown type -- ANGLE" z))))
       #+END_SRC
****** Predicates for recognizing rectangular and polar types using tags
       #+NAME: predicates
       #+BEGIN_SRC scheme
         (define (rectangular? z)
           (eq? (type-tag z) 'rectangular))
         (define (polar? z)
           (eq? (type-tag z) 'polar))
       #+END_SRC
****** Selectors and constructors for rectangular type
       #+NAME: rectangular-selectors-and-constructors
       #+BEGIN_SRC scheme
         (define (real-part-rectangular z) (car z))
         (define (imag-part-rectangular z) (cdr z))
         (define (magnitude-rectangular z)
           (sqrt (+ (square (real-part-rectangular z))
                    (square (imag-part-rectangular z)))))
         (define (angle-rectangular z)
           (atan (imag-part-rectangular z)
                 (real-part-rectangular z)))
         (define (make-from-real-imag-rectangular x y)
           (attach-tag 'rectangular (cons x y)))
       #+END_SRC
****** Selectors and constructors for polar type
       #+NAME: polar-selectors-and-constructors
       #+BEGIN_SRC scheme
         (define (real-part-polar z)
           (* (magnitude-polar z) (cos (angle-polar z))))
         (define (imag-part-polar z)
           (* (magnitude-polar z) (sin (angle-polar z))))
         (define (magnitude-polar z) (car z))
         (define (angle-polar z) (cdr z))
         (define (make-from-mag-ang-polar r a)
           (attach-tag 'polar (cons r a)))
       #+END_SRC
****** Tag functions
       #+NAME: tag-functions
       #+BEGIN_SRC scheme
         (define (attach-tag type-tag contents)
           (cons type-tag contents))
         (define (type-tag datum)
           (if (pair? datum)
               (car datum)
               (error "Bad tagged datum -- TYPE-TAG" datum)))
         (define (contents datum)
           (if (pair? datum)
               (cdr datum)
               (error "Bad tagged datum -- CONTENTS" datum)))
       #+END_SRC
****** Reasonable implementations of constructors
       #+NAME: constructors
       #+BEGIN_SRC scheme
         (define (make-from-real-imag x y)
           (make-from-real-imag-rectangular x y))
         (define (make-from-mag-ang r a)
           (make-from-mag-ang-polar r a))
       #+END_SRC
****** Source Code
       #+NAME: complex_numbers
       #+BEGIN_SRC scheme :tangle complex_numbers_naive.scm :noweb yes
         <<operations>>
         <<selectors>>
         <<predicates>>
         <<rectangular-selectors-and-constructors>>
         <<polar-selectors-and-constructors>>
         <<tag-functions>>
         <<constructors>>
       #+END_SRC
***** Data-directed approach
****** Table of operations for the complex number system
       |------------+-----------------+-----------------------|
       | Operations | Polar           | Rectangular           |
       |------------+-----------------+-----------------------|
       | real-part  | real-part-polar | real-part-rectangular |
       | imag-part  | imag-part-polar | imag-part-rectangular |
       | magnitude  | magnitude-polar | magnitude-rectangular |
       | angle      | angle-polar     | angle-rectangular     |
       |------------+-----------------+-----------------------|
****** Procedures to manipulate the table
       - =(put <op> <type> <item>)=
         Installs the =<item>= in the table, indexed by the =<op>= and =<type>=
       - =(get <op> <type>)=
         Looks up the =<op>=, =<type>= entry in the table and returns the =<item>= found there.
         If no =<item>= is found, =get= returns =false=

****** Install rectangular package
       #+NAME: install-rectangular-package
       #+BEGIN_SRC scheme
         (define (install-rectangular-package)
           ;; internal procedures
           (define (real-part z) (car z))
           (define (imag-part z) (cdr z))
           (define (make-from-real-imag x y) (cons x y))
           (define (magnitude z)
             (sqrt (+ (square (real-part z))
                      (square (imag-part z)))))
           (define (angle z)
             (atan (imag-part z) (real-part z)))
           (define (make-from-mag-ang r a)
             (cons (* r (cos a)) (* r (sin a))))

           ;; interface to the rest of the system
           (define (tag x) (attach-tag 'rectangular x))
           (put 'real-part '(rectangular) real-part)
           (put 'imag-part '(rectangular) imag-part)
           (put 'magnitude '(rectangular) magnitude)
           (put 'angle '(rectangular) angle)
           (put 'make-from-real-imag 'rectangular
                (lambda (x y) (tag (make-from-real-imag x y))))
           (put 'make-from-mag-ang 'rectangular
                (lambda (r a) (tag (make-from-mag-ang r a))))
           'done)
       #+END_SRC
       
****** Install polar package
       #+NAME: install-polar-package
       #+BEGIN_SRC scheme
         (define (install-polar-package)
           ;; internal procedures
           (define (magnitude z) (car z))
           (define (angle z) (cdr z))
           (define (make-from-mag-ang r a) (cons r a))
           (define (real-part z)
             (* (magnitude z) (cos (angle z))))
           (define (imag-part z)
             (* (magnitude z) (sin (angle z))))
           (define (make-from-real-imag x y)
             (cons (sqrt (+ (square x) (square y)))
                   (atan y x)))

           ;; interface to the rest of the system
           (define (tag x) (attach-tag 'polar x))
           (put 'real-part '(polar) real-part)
           (put 'imag-part '(polar) imag-part)
           (put 'magnitude '(polar) magnitude)
           (put 'angle '(polar) angle)
           (put 'make-from-real-imag 'polar
                (lambda (x y) (tag (make-from-real-imag x y))))
           (put 'make-from-mag-ang 'polar
                (lambda (r a) (tag (make-from-mag-ang r a))))
           'done)
       #+END_SRC

****** Define generic selectors using apply-generic
       #+NAME: generic-selectors-using-table
       #+BEGIN_SRC scheme
         (define (real-part z) (apply-generic 'real-part z))
         (define (imag-part z) (apply-generic 'imag-part z))
         (define (magnitude z) (apply-generic 'magnitude z))
         (define (angle z) (apply-generic 'angle z))
       #+END_SRC

       #+NAME: apply-generic
       #+BEGIN_SRC scheme
         (define (apply-generic op . args)
           (let ((type-tags (map type-tag args)))
             (let ((proc (get op type-tags)))
               (if proc
                   (apply proc (map contents args))
                   (error
                    "No method for these types -- APPLY-GENERIC"
                    (list op type-tags))))))
       #+END_SRC

****** Extract the constructors from the table
       #+NAME: constructors-using-table
       #+BEGIN_SRC scheme
         (define (make-from-real-imag x y)
           ((get 'make-from-real-imag 'rectangular) x y))

         (define (make-from-mag-ang r a)
           ((get 'make-from-mag-ang 'polar) r a))
       #+END_SRC

****** Implementation of the table
       #+NAME: table-implementation
       #+BEGIN_SRC scheme
         ;; Helper functions --- implementation of two dimensional table
         (define (assoc key records)
           (cond ((null? records) false)
                 ((equal? key (caar records)) (car records))
                 (else (assoc key (cdr records)))))

         (define (make-table)
           (let ((local-table (list '*table*)))
             (define (lookup key-1 key-2)
               (let ((subtable (assoc key-1 (cdr local-table))))
                 (if subtable
                     (let ((record (assoc key-2 (cdr subtable))))
                       (if record
                           (cdr record)
                           false))
                     false)))
             (define (insert! key-1 key-2 value)
               (let ((subtable (assoc key-1 (cdr local-table))))
                 (if subtable
                     (let ((record (assoc key-2 (cdr subtable))))
                       (if record
                           (set-cdr! record value)
                           (set-cdr! subtable
                                     (cons (cons key-2 value)
                                           (cdr subtable)))))
                     (set-cdr! local-table
                               (cons (list key-1
                                           (cons key-2 value))
                                     (cdr local-table)))))
               'ok)
             (define (dispatch m)
               (cond ((eq? m 'lookup-proc) lookup)
                     ((eq? m 'insert-proc!) insert!)
                     (else (error "Unknown operation -- TABLE" m))))
             dispatch))

         (define operation-table (make-table))
         (define get (operation-table 'lookup-proc))
         (define put (operation-table 'insert-proc!))


       #+END_SRC

****** Source code
       #+NAME: complex_numbers_data_directed
       #+BEGIN_SRC scheme :tangle complex_numbers_data_directed.scm :noweb yes
         <<operations>>
         <<tag-functions>>
         <<install-rectangular-package>>
         <<install-polar-package>>
         <<generic-selectors-using-table>>
         <<constructors-using-table>>
         <<apply-generic>>
         <<table-implementation>>
       #+END_SRC

**** 4.1 
***** The Metacircular Evaluator
****** The Core of the Evaluator
       The evaluation process can be described as the interplay between two procedures: =eval= and =apply=.
******* Eval
        =Eval= takes as arguments an expression and an environment. It classifies the expression and directs its evaluation.
        =Eval= is structured as a case analysis of the syntactic type of the expression to be evaluated. In order to keep the procedure general,
        we express the determination of the type of an expression abstractly,
        making no commitment to any particular representation for the various types of expressions.
        Each type of expression has a predicate that tests for it and an abstract means for selecting its parts.
        This /abstract syntax/ makes it easy to see how we can change the syntax of the language by using the same evaluator,
        but with a different collection of syntax procedures.
        
        - /Primitive Expressions/
          - For self-evaluating expressions, such as numbers, =eval= returns the expression itself.
          - =Eval= must look up variables in the environment to find their values.


        - /Special Forms/
          - For quoted expressions, =eval= returns the expression that was quoted.
          - An assignment to (or a definition of) a variable must recursively call =eval=
            to compute the new value to be associated with the variable.
            The environment must be modified to change (or create) the binding of the variable.
          - An =if= expression requires special processing of its parts, so as to evaluate the consequent if the predicate is true,
            and otherwise to evaluate the alternative.
          - A =lambda= expression must be transformed into an applicable procedure by packing together the parameters and body
            specified by the =lambda= expression with the environment of the evaluation.
          - A =begin= expression requires evaluating its sequence of expressions in the order in which they appear.
          - A case analysis (=cond=) is transformed into a nest of if expressions and then evaluated.


        - /Combinations/
          - For a procedure application, =eval= must recursively evaluate the operator part and the operands of the combination.
            The resulting procedure and arguments are passed to =apply=, which handles the actual procedure application.


        Here is the definition of =eval=:

        #+NAME: eval
        #+BEGIN_SRC scheme
          (define (eval exp env)
            (cond ((self-evaluating? exp) exp)
                  ((variable? exp) (lookup-variable-value exp env))
                  ((quoted? exp) (text-of-quotation exp))
                  ((assignment? exp) (eval-assignment exp env))
                  ((definition? exp) (eval-definition exp env))
                  ((if? exp) (eval-if exp env))
                  ((lambda? exp)
                   (make-procedure (lambda-parameters exp)
                                   (lambda-body exp)
                                   env))
                  ((let? exp) (eval (let->combination exp) env))
                  ((let*? exp) (eval (let*->nested-lets exp) env))
                  ((begin? exp)
                   (eval-sequence (begin-actions exp) env))
                  ((cond? exp) (eval (cond->if exp) env))
                  ((application? exp)
                   (apply (eval (operator exp) env)
                          (list-of-values (operands exp) env)))
                  (else
                   (error "Unknown expression type -- EVAL" exp))))
        #+END_SRC
        
        For clarity, =eval= has been implemented as a case analysis using =cond=. 
        The disadvantage of this is that our procedure handles only a few distinguishable types of expressions,
        and no new ones can be defined without editing the definition of =eval=.
        In most Lisp implementations, dispatching on the type of an expression is done in a data-directed style.
        This allows a user to add new types of expressions that =eval= can distinguish, without modifying the definition of =eval= itself.

******* Apply
        =Apply= takes two arguments, a procedure and a list of arguments to which the procedure should be applied.
        =Apply= classifies procedures into two kinds: It calls =apply-primitive-procedure= to apply primitives;
        it applies compound procedures by sequentially evaluating the expressions that make up the body of the procedure.
        The environment for the evaluation of the body of a compound procedure is constructed by extending the base environment
        carried by the procedure to include a frame that binds the parameters of the procedure to the arguments
        to which the procedure is to be applied.
        Here is the definition of =apply=:
        
        #+NAME: apply
        #+BEGIN_SRC  scheme
          (define (apply procedure arguments)
            (cond ((primitive-procedure? procedure)
                   (apply-primitive-procedure procedure arguments))
                  ((compound-procedure? procedure)
                   (eval-sequence
                    (procedure-body procedure)
                    (extend-environment
                     (procedure-parameters procedure)
                     arguments
                     (procedure-environment procedure))))
                  (else
                   (error
                    "Unknown procedure type -- APPLY" procedure))))
        #+END_SRC
******* Procedure arguments
        When =eval= processes a procedure application, it uses =list-of-values= to produce the list of arguments
        to which the procedure is to be applied.
        =List-of-values= takes as an argument the operands of the combination.
        It evaluates each operand and returns a list of the corresponding values:
        
        #+NAME: list-of-values
        #+BEGIN_SRC scheme
          (define (list-of-values exps env)
            (if (no-operands? exps)
                '()
                (cons (eval (first-operand exps) env)
                      (list-of-values (rest-operands exps) env))))
        #+END_SRC

******** Ex4.1
         #+NAME: list-of-values-left-to-right
         #+BEGIN_SRC scheme
           (define (list-of-values exps env)
             (if (no-operands? exps)
                 '()
                 (let* ((left (eval (first-operand exps) env))
                        (right (list-of-values (rest-operands exps) env)))
                   (cons left right))))
         #+END_SRC

         #+NAME: list-of-values-right-to-left
         #+BEGIN_SRC scheme
           (define (list-of-values exps env)
             (if (no-operands? exps)
                 '()
                 (let* ((right (list-of-values (rest-operands exps) env))
                        (left (eval (first-operand exps) env)))
                   (cons left right))))
         #+END_SRC

******* Conditionals
        =Eval-if= evaluates the predicate part of an =if= expression in the given environment.
        If the result is true, =eval-if= evaluates the consequent, otherwise it evaluates the alternative:

        #+NAME: eval-if
        #+BEGIN_SRC scheme
          (define (eval-if exp env)
            (if (true? (eval (if-predicate exp) env))
                (eval (if-consequent exp) env)
                (eval (if-alternative exp) env)))
        #+END_SRC

        The use of =true?= in =eval-if= highlights the issue of the connection between an implemented language and an implementation language.
        The =if-predicate= is evaluated in the language being implemented and thus yields a value in that language.
        The interpreter predicate =true?= translates that value into a value that can be tested by the =if= in the implementation language:
        The metacircular representation of truth might not be the same oas that of the underlying Scheme.

******* Sequences
        =Eval-sequence= is used by =apply= to evaluate the sequence of expressions in a procedure body and by =eval=
        to evaluate the sequence of expressions in a =begin= expression.
        It takes as arguments a sequence of expressions and an environment, and evaluates the expressions in the order in which they occur.
        The value returned is the value of the final expression.
        
        #+NAME: eval-sequence
        #+BEGIN_SRC scheme
          (define (eval-sequence exps env)
            (cond ((last-exp? exps) (eval (first-exp exps) env))
                  (else (eval (first-exp exps) env)
                        (eval-sequence (rest-exps exps) env))))
        #+END_SRC
******* Assignments and definitions
        The following procedure handles assignments to variables.
        It calls =eval= to find the value to be assigned and transmits the variable and the resulting value to =set-variable-value!=
        to be installed in the designated environment.
        
        #+NAME: eval-assignment
        #+BEGIN_SRC scheme
          (define (eval-assignment exp env)
            (set-variable-value! (assignment-variable exp)
                                 (eval (assignment-value exp) env)
                                 env)
            'ok)
        #+END_SRC

        Definitions of variables are handled in a similar manner.

        #+NAME: eval-definition
        #+BEGIN_SRC scheme
          (define (eval-definition exp env)
            (define-variable! (definition-variable exp)
              (eval (definition-value exp) env)
              env)
            'ok)
        #+END_SRC

        We have chosen here to return the symbol =ok= as the value of an assignment or a definition.
******** Exercise 4.2
         #+begin_quote
         Louis Reasoner plans to reorder the cond clauses in eval so that the clause
         for procedure applications appears before the clause for assignments.
         He argues that this will make the interpreter more efficient:
         Since programs usually contain more applications than assignments, definitions, and so on,
         his modified eval will usually check fewer clauses than the original eval before identifying the type of an expression.
         #+end_quote

         #+NAME: eval-ex-4.2
         #+BEGIN_SRC scheme
           (define (eval exp env)
             (cond ((self-evaluating? exp) exp)
                   ((variable? exp) (lookup-variable-value exp env))
                   ((quoted? exp) (text-of-quotation exp))
                   ((application? exp)
                    (apply (eval (operator exp) env)
                           (list-of-values (operands exp) env)))
                   ((assignment? exp) (eval-assignment exp env))
                   ((definition? exp) (eval-definition exp env))
                   ((if? exp) (eval-if exp env))
                   ((lambda? exp)
                    (make-procedure (lambda-parameters exp)
                                    (lambda-body exp)
                                    env))
                   ((begin? exp)
                    (eval-sequence (begin-actions exp) env))
                   ((cond? exp) (eval (cond->if exp) env))

                   (else
                    (error "Unknown expression type -- EVAL" exp))))
         #+END_SRC

         #+NAME: procedure-application-ex-4.2
         #+BEGIN_SRC scheme
           (define (application? exp) (tagged-list? exp 'call))

           (define (operator exp) (cadr exp))

           (define (operands exp) (cddr exp))

           (define (no-operands? ops) (null? ops))

           (define (first-operand ops) (car ops))

           (define (rest-operands ops) (cdr ops))
         #+END_SRC

******** Exercise 4.3
         #+begin_quote
         Rewrite eval so that the dispatch is done in data-directed style.
         Compare this with the data-directed differentiation procedure of exercise 2.73.
         (You may use the car of a compound expression as the type of the expression, as is appropriate for the syntax implemented in this section.) 
         #+end_quote
         
         #+NAME: eval-ex-4.3
         #+BEGIN_SRC scheme
           (define (eval exp env)
             (cond ((self-evaluating? exp) exp)
                   ((variable? exp) (lookup-variable-value exp env))
                   ((get 'eval (car exp)) ((get 'eval (car exp)) exp env))
                   ((application? exp)
                    (apply (eval (operator exp) env)
                           (list-of-values (operands exp) env)))
                   (else
                    (error "Unknown expression type -- EVAL" exp))))

           (put 'eval 'quote text-of-quotation)
           (put 'eval 'set! eval-assignment)
           (put 'eval 'define eval-definition)
           (put 'eval 'if eval-if)
           (put 'eval 'lambda (lambda (x y)
                                (make-procedure (lambda-parameters x) (lambda-body x) y)))
           (put 'eval 'begin (lambda (x y)
                               (eval-sequence (begin-sequence x) y)))
           (put 'eval 'cond (lambda (x y)
                              (evaln (cond->if x) y)))
         #+END_SRC
******** Exercise 4.4
         #+begin_quote
         Recall the definitions of the special forms and and or from chapter 1:

         *and*: The expressions are evaluated from left to right.
                If any expression evaluates to false, false is returned;
                any remaining expressions are not evaluated.
                If all the expressions evaluate to true values, the value of the last expression is returned.
                If there are no expressions then true is returned.
         *or*: The expressions are evaluated from left to right.
               If any expression evaluates to a true value, that value is returned;
               any remaining expressions are not evaluated.
               If all expressions evaluate to false, or if there are no expressions, then false is returned.

         Install and and or as new special forms for the evaluator by defining appropriate syntax procedures and evaluation procedures eval-and and eval-or. Alternatively, show how to implement and and or as derived expressions.
         #+end_quote

         #+NAME: eval-ex-4-4
         #+BEGIN_SRC scheme
           (define (eval exp env)
             (cond ((self-evaluating? exp) exp)
                   ((variable? exp) (lookup-variable-value exp env))
                   ((quoted? exp) (text-of-quotation exp))
                   ((assignment? exp) (eval-assignment exp env))
                   ((definition? exp) (eval-definition exp env))
                   ((if? exp) (eval-if exp env))
                   ((lambda? exp)
                    (make-procedure (lambda-parameters exp)
                                    (lambda-body exp)
                                    env))
                   ((begin? exp)
                    (eval-sequence (begin-actions exp) env))
                   ((cond? exp) (eval (cond->if exp) env))
                   ((and? exp) (eval-and exp env))
                   ((or? exp) (eval-or exp env))
                   ((application? exp)
                    (apply (eval (operator exp) env)
                           (list-of-values (operands exp) env)))
                   (else
                    (error "Unknown expression type -- EVAL" exp))))
         #+END_SRC

         #+NAME: eval-and
         #+BEGIN_SRC scheme
           (define (and? exp) (tagged-list? exp '_and))

           (define (and-predicates exp) (cdr exp))
           (define (eval-and-predicates predicates env)
             (cond ((null? predicates)
                    true)
                   ((null? (cdr predicates))
                    (eval (car predicates) env))
                   ((true? (eval (car predicates) env))
                    (eval-and-predicates (cdr predicates) env))
                   (else
                    false)))

           (define (eval-and exp env)
             (eval-and-predicates (and-predicates exp) env))
         #+END_SRC

         #+NAME: eval-or
         #+BEGIN_SRC scheme
           (define (or? exp) (tagged-list? exp '_or))
           (define (or-predicates exp) (cdr exp))
           (define (eval-or-predicates predicates env)
             (cond ((null? predicates)
                    false)
                    ((true? (eval (car predicates) env))
                     (eval (car predicates) env))
                    (else
                     (eval-or-predicates (cdr predicates) env))))
           (define (eval-or exp env)
             (eval-or-predicates (or-predicates exp) env))
         #+END_SRC

         #+NAME:
         #+BEGIN_SRC scheme
         #+END_SRC

         #+NAME:
         #+BEGIN_SRC scheme
         #+END_SRC
******** Exercise 4.5
         #+begin_quote
         Scheme allows an additional syntax for cond clauses, (<test> => <recipient>).
         If <test> evaluates to a true value, then <recipient> is evaluated.
         Its value must be a procedure of one argument; this procedure is then invoked on the value of the <test>,
         and the result is returned as the value of the cond expression.
         For example

         (cond ((assoc 'b '((a 1) (b 2))) => cadr)
           (else false))

         returns 2. Modify the handling of cond so that it supports this extended syntax.
         #+end_quote

         #+NAME: cond-ex-4.5
         #+BEGIN_SRC scheme
           (define (cond? exp)
             (tagged-list? exp 'cond))

           (define (cond-clauses exp)
             (cdr exp))

           (define (cond-predicate clause)
             (car clause))

           (define (cond-recipient clause)
             (caddr clause))

           (define (cond-recipient-clause? clause)
             (eq? (cadr clause) '=>))

           (define (cond-else-clause? clause)
             (eq? (cond-predicate clause) 'else))

           (define (make-cond-recipient clause predicate)
             (list (cond-recipient clause) predicate))

           (define (cond-actions clause)
             (cdr clause))

           (define (cond-consequent clause predicate)
             (if (cond-recipient-clause? clause)
                 (make-cond-recipient clause predicate)
                 (sequence->exp (cond-actions clause))))

           (define (cond->if exp)
             (expand-clauses (cond-clauses exp)))

           (define (expand-clauses clauses)
             (if (null? clauses)
                 false
                 (let ((first (car clauses))
                       (rest (cdr clauses)))
                   (if (cond-else-clause? first)
                       (if (null? rest)
                           (sequence->exp (cond-actions first))
                           (error "ELSE clause isn't last -- COND->IF" clauses))
                       (let ((predicate (cond-predicate first)))
                         (make-if predicate
                                  (cond-consequent first predicate)
                                  (expand-clauses rest)))))))
         #+END_SRC
******** Exercise 4.6
         #+begin_quote
         =Let= expressions are derived expressions, because

           (let ((<var1> <exp1>) ... (<varn> <expn>)) <body>)

         is equivalent to

           ((lambda (<var1> ... <varn>)
              <body>)
            <exp1>
            ...
            <expn>)

           Implement a syntactic transformation =let->combination= that reduces
           evaluating =let= expressions to evaluating combinations of the type shown above,
           and add the appropriate clause to =eval= to handle let expressions.
         #+end_quote

         #+NAME: let-ex-4.6
         #+BEGIN_SRC scheme
           (define (let? exp) (tagged-list? exp 'let))

           (define (let-assignments exp) (cadr exp))
           (define (let-assignment-name assignment) (car assignment))
           (define (let-assignment-value assignment) (cadr assignment))
           (define (let-body exp) (cddr exp))

           (define (let-assignment-names assignments)
             (map let-assignment-name assignments))

           (define (let-assignment-values assignments)
             (map let-assignment-value assignments))

           (define (let->combination exp)
             (cons (make-lambda (let-assignment-names (let-assignments exp))
                                (let-body exp))
                   (let-assignment-values (let-assignments exp))))
         #+END_SRC
******** Exercise 4.7
         #+begin_quote
         =Let*= is similar to =let=, except that the bindings of the =let= variables are performed
         sequentially from left to right, and each binding is made in an environment in which
         all of the preceding bindings are visible. For example

         (let* ((x 3)
           (y (+ x 2))
           (z (+ x y 5)))
           (* x z))

          returns 39. Explain how a =let*= expression can be rewritten as a set of nested =let=
          expressions, and write a procedure =let*->nested-lets= that performs this transformation.
          If we have already implemented =let= (exercise 4.6) and we want to extend the evaluator
          to handle =let*=, is it sufficient to add a clause to eval whose action is =(eval (let*->nested-lets exp) env)=
          or must we explicitly expand =let*= in terms of non-derived expressions? 
         #+end_quote

         #+NAME: let-ex-4.7
         #+BEGIN_SRC scheme

           (define (let*? exp) (tagged-list? exp 'let*))
           (define (let-args exp) (cadr exp))
           (define (let-body exp) (cddr exp))
           (define (make-let args body) (cons 'let (cons args body)))

           (define (let*->nested-lets exp)
             (define (reduce-let* args body)
               (if (null? args)
                   (sequence->exp body)
                   (make-let (list (car args))
                             (list (reduce-let* (cdr args) body)))))
             (reduce-let* (let-args exp) (let-body exp)))
         #+END_SRC         
****** Representing Expressions
       The evaluator is reminiscent of the symbolic differentiation program discussed in section 2.3.2.
       both programs operate on symbolic expressions. In both programs, the result of operating on a compound expression is determined by
       operating recursively on the pieces of the expression and combining the results in a way that depends on the type of the expression.
       In both programs we used data abstraction to decouple the general rules of operation from the details of how expressions are represented.
       In the differentiation program this meant that the same differentiation procedure could deal with algebraic expressions in prefix form,
       in infix form, or in some other form. For the evaluator, this means that the syntax of the language being evaluated is determined solely
       by the procedures that classify and extract pieces of expressions.

       Here is the specification of the syntax of our language:

******* The only self-evaluating items are numbers and strings:
        #+NAME: self-evaluating-items
        #+BEGIN_SRC scheme
          (define (self-evaluating? exp)
            (cond ((number? exp) true)
                  ((string? exp) true)
                  (else false)))
        #+END_SRC

******* Variables are represented by symbols:
        #+NAME: variables
        #+BEGIN_SRC scheme
          (define (variable? exp) (symbol? exp))
        #+END_SRC

******* Quotations have the form =(quote <text-of-quotation>)=:
        #+NAME: quotations
        #+BEGIN_SRC scheme
          (define (quoted? exp)
            (tagged-list? exp 'quote))

          (define (text-of-quotation exp) (cadr exp))
        #+END_SRC

        =Quoted?= is defined in terms of the procedure =tagged-list?=, which identifies lists beginning with a designated symbol:

        #+NAME: tagged-list
        #+BEGIN_SRC scheme
          (define (tagged-list? exp tag)
            (if (pair? exp)
                (eq? (car exp) tag)
                false))
        #+END_SRC

******* Assignments have the form =(set! <var> <value>)=:
        #+NAME: assignments
        #+BEGIN_SRC scheme
          (define (assignment? exp)
            (tagged-list? exp 'set!))

          (define (assignment-variable exp) (cadr exp))

          (define (assignment-value exp) (caddr exp))
        #+END_SRC
       
******* Definitions have the form 
        =(define <var> <value>)=
        
        or the form

        =(define (<var> <param1> <param2> ... <paramn>) <body>)=
        
        The latter form (standard procedure definition) is syntactic sugar for

        #+BEGIN_SRC scheme
          (define <var>
            (lambda (<param1> ... <paramn>)
              <body>))
        #+END_SRC

        The corresponding syntax procedures are the following:

        #+NAME: definitions
        #+BEGIN_SRC scheme
          (define (definition? exp) (tagged-list? exp 'define))

          (define (definition-variable exp)
            (if (symbol? (cadr exp))
                (cadr exp)
                (caadr exp)))

          (define (definition-value exp)
            (if (symbol? (cadr exp))
                (caddr exp)
                (make-lambda (cdadr exp)   ;formal parameters
                             (cddr exp)))) ;body
        #+END_SRC
      
******* Lambda expressions are lists that begin with the symbol =lambda=:
        #+NAME: lambda-expressions
        #+BEGIN_SRC scheme
          (define (lambda? exp) (tagged-list? exp 'lambda))

          (define (lambda-parameters exp) (cadr exp))

          (define (lambda-body exp) (cddr exp))

          (define (make-lambda parameters body)
            (cons 'lambda (cons parameters body)))
        #+END_SRC

******* Conditionals begin with =if= and have a predicate, a consequent, and an (optional) alternative. If the expression has no alternative part, we provide =false= as the alternative.
        #+NAME: if-conditionals
        #+BEGIN_SRC scheme
          (define (if? exp) (tagged-list? exp 'if))

          (define (if-predicate exp) (cadr exp))

          (define (if-consequent exp) (caddr exp))

          (define (if-alternative exp)
            (if (not (null? (cdddr exp)))
                (cadddr exp)
                'false))

          (define (make-if predicate consequent alternative)
            (list 'if predicate consequent alternative))
        #+END_SRC

******* =Begin= packages a sequence of expressions into a single expression.

        We include syntax operations on =begin= expressions to extract the actual sequence from the =begin= expression,
        as well as selectors that return the first expression and the rest of the expressions in the sequence.
       
        #+NAME: begin
        #+BEGIN_SRC scheme
          (define (begin? exp) (tagged-list? exp 'begin))

          (define (begin-actions exp) (cdr exp))

          (define (last-exp? seq) (null? (cdr seq)))

          (define (first-exp seq) (car seq))

          (define (rest-exps seq) (cdr seq))

          (define (make-begin seq) (cons 'begin seq))

          (define (sequence->exp seq)
            (cond ((null? seq) seq)
                  ((last-exp? seq) (first-exp seq))
                  (else (make-begin seq))))
        #+END_SRC

        We also include a constructor =sequence->exp= (for use by =cond-if=) that transforms a sequence into a single expression,
        using =begin= if necessary:

        #+NAME: sequence->exp
        #+BEGIN_SRC scheme
          (define (sequence->exp seq)
            (cond ((null? seq) seq)
                  ((last-exp? seq) (first-exp seq))
                  (else (make-begin seq))))

          (define (make-begin seq) (cons 'begin seq))
        #+END_SRC

******* A procedure application is any compound expression that is not one of the above expression types. The =car= of the expression is the operator, and the =cdr= is the list of operands:
        #+NAME: procedure-application
        #+BEGIN_SRC scheme
          (define (application? exp) (pair? exp))

          (define (operator exp) (car exp))

          (define (operands exp) (cdr exp))

          (define (no-operands? ops) (null? ops))

          (define (first-operand ops) (car ops))

          (define (rest-operands ops) (cdr ops))
        #+END_SRC
******* Derived expressions
        Some special forms in our languages can be defined in terms of expressions involving other special forms,
        rather than being implemented directly.
        One example is =cond=, which can be implemented as a nest of =if= expressions.
        For example, we can reduce the problem of evaluating the expression

        #+BEGIN_SRC scheme
          (cond ((> x 0) x)
                ((= x 0) (display 'zero) 0)
                (else (- x)))
        #+END_SRC

        to the problem of evaluating the following expression involving =if= and =begin= expressions:

        #+BEGIN_SRC scheme
          (if (> x 0)
              x
              (if (= x 0)
                  (begin (display 'zero)
                         0)
                  (- x)))
        #+END_SRC

        Implementing the evaluation of =cond= in this way simplifies the evaluator because it reduces the number of special forms
        for which the evaluation process must be explicitly specified.

        We include syntax procedures that extract the parts of a =cond= expression and procedure =cond->if= that transforms =cond= expressions
        into =if= expressions.
        A case analysis begins with =cond= and has a list of predicate-action clauses.
        A clause is an =else= clause if its predicate is the symbol =else=.

        #+NAME: cond
        #+BEGIN_SRC scheme

          (define (cond? exp) (tagged-list? exp 'cond))

          (define (cond-clauses exp) (cdr exp))

          (define (cond-predicate clause) (car clause))

          (define (cond-actions clause) (cdr clause))

          (define (cond-else-clause? clause)
            (eq? (cond-predicate clause) 'else))

          (define (cond->if exp)
            (expland-clauses (cond-clauses exp)))

          (define (expand-clauses clauses)
            (if (null? clauses)
                'false
                (let ((first (car clauses))
                      (rest (cdr clauses)))
                  (if (cond-else-clause? first)
                      (if (null? rest)
                          (sequence->exp (cond-actions first))
                          (error "ELSE clause isn't last -- COND->IF"
                                 clauses))
                      (make-if (cond-predicate first)
                               (sequence->exp (cond-actions first))
                               (expand-clauses rest))))))
        #+END_SRC

        Expressions (such as =cond=) that we choose to implement as syntactic transformations are called /derived expressions/.
        =Let= expressions are also derived expressions.
****** Evaluator Data Structures
       In addition to defining the external syntax of expressions,
       the evaluator implementation must also define the data structures that the evaluator manipulates internally,
       as part of the execution of a program,
       such as the representation of procedures and environments and the representation of true and false.
******* Testing of predicates
        For conditionals, we accept anything to be true that is not the explicit =false= object.
        #+NAME: testing-of-predicates
        #+BEGIN_SRC scheme
          (define (true? x)
            (not (eq? x false)))

          (define (false? x)
            (eq? x false))
        #+END_SRC
******* Representing procedures
        To handle primitives, we assume that we have available the following procedures:

        - =(apply-primitive-procedure <proc> <args>)=
          applies the given primitive procedure to the argument values in the list /<args>/ and returns the result of the application.
        - =(primitive-procedure? <proc>)=
          tests whether /<proc>/ is a primitive procedure.

          These mechanisms for handling primitives are further described in section 4.1.4.

          Compound procedures are constructed from parameters, procedure bodies, and environments using the constructor =make-procedure=:

        #+NAME: procedures
        #+BEGIN_SRC scheme
          (define (make-procedure parameters body env)
            (list 'procedure parameters body env))

          (define (compound-procedure? p)
            (tagged-list? p 'procedure))

          (define (procedure-parameters p) (cadr p))

          (define (procedure-body p) (caddr p))

          (define (procedure-environment p) (cadddr p))
        #+END_SRC
******* Operations on Environments
        The evaluator needs operations for manipulating environments. As explained in section 3.2, an environment is a sequence of frames,
        where each frame is a table of bindings that associate variables with their corresponding values.
        We use the following operations for manipulating environments:

        - =(loopup-variable-value <var> <env>)=
          returns the value that is bound to the symbol /<var>/ in the environment /env/, or signals an error if the variable if unbound.
        - =(extend-environment <variables> <values> <base-env>)=
          returns a new environment, consisting of a new frame in which the symbols in the list /<variables>/
          are bound to the corresponding elements in the list /<values>/, where the enclosing environment is the environment /<base-env>/.
        - =(define-variable! <var> <value> <env>)=
          adds to the first frame in the environment /<env>/ a new binding that associates the variable /<var>/ with the value /<value>>.
        - =(set-variable-value! <var> <value> <env>)=
          changes the binding of the variable /<var>/ in the environment /<env>/ so that the variable is now bound to value /<value>/,
          or signals an error if the variable is unbound.
          
          To implement these operations we represent an environment as a list of frames.
          The enclosing environment of an environment is the =cdr= of the list. The empty environment is simply an empty list.
        #+NAME: env-1
        #+BEGIN_SRC scheme
          (define (enclosing-environment env) (cdr env))

          (define (first-frame env) (car env))

          (define the-empty-environment '())
        #+END_SRC
        
        Each frame of an environment is represented as a pair of lists: a list of the variables bound in that frame
        and a list of the associated values.

        #+NAME: env-2
        #+BEGIN_SRC scheme
          (define (make-frame variables values)
            (cons variables values))

          (define (frame-variables frame) (car frame))

          (define (frame-values frame) (cdr frame))

          (define (add-binding-to-frame! var val frame)
            (set-car! frame (cons var (car frame)))
            (set-cdr! frame (cons val (cdr frame))))
        #+END_SRC

        To extend an environment by a new frame that associates variables with values,
        we make a frame consisting of the list of variables and the list of values, and we adjoin this to the environment.
        We signal an error if the number of variables does not match the number of values.

        #+NAME: env-3
        #+BEGIN_SRC scheme
          (define (extend-environment vars vals base-env)
            (if (= (length vars) (length vals))
                (cons (make-frame vars vals) base-env)
                (if (< (length vars) (length vals))
                    (error "Too many arguments supplied" vars vals)
                    (error "Too few arguments supplied" vars vals))))
        #+END_SRC

        To look up a variable in an environment, we scan the list of variables in the first frame.
        If we find the desired variable, we return the corresponding element in the list of values.
        If we do not find the variable in the current frame, we search the enclosing environment, and so on.
        If we reach the empty environment, we signal an "unbound variable" error.

        #+NAME: env-4
        #+BEGIN_SRC scheme
          (define (lookup-variable-value var env)
            (define (env-loop env)
              (define (scan vars vals)
                (cond ((null? vars)
                       (env-loop (enclosing-environment env)))
                      ((eq? var (car vars))
                       (car vals))
                      (else (scan (cdr vars) (cdr vals)))))
              (if (eq? env the-empty-environment)
                  (error "Unbound variable" var)
                  (let ((frame (first-frame env)))
                    (scan (frame-variables frame)
                          (frame-values frame)))))
            (env-loop env))
        #+END_SRC

        To set a variable to a new value in a specified environment, we scan for the variable,
        just as in =lookup-variable-value=, and change the corres value when we find it.

        #+NAME: env-5
        #+BEGIN_SRC scheme
          (define (set-variable-value! var val env)
            (define (env-loop env)
              (define (scan vars vals)
                (cond ((null? vars)
                       (env-loop (enclosing-environment env)))
                      ((eq? var (car vars))
                       (set-car! vals val))
                      (else (scan (cdr vars) (cdr vals)))))
              (if (eq? env the-empty-environment)
                  (error "Unbound variable -- SET!" var)
                  (let ((frame (first-frame env)))
                    (scan (frame-variables frame)
                          (frame-values frame)))))
            (env-loop env))
        #+END_SRC

        To define a variable, we search the first frame for a binding for the variable,
        and change the binding if it exists (just as in =set-variable-value!=).
        If no such binding exists, we adjoin one to the first frame.

        #+NAME: env-6
        #+BEGIN_SRC scheme
          (define (define-variable! var val env)
            (let ((frame (first-frame env)))
              (define (scan vars vals)
                (cond ((null? vars)
                       (add-binding-to-frame! var val frame))
                      ((eq? var (car vars))
                       (set-car! vals val))
                      (else (scan (cdr vars) (cdr vals)))))
              (scan (frame-variables frame)
                    (frame-values frame))))
        #+END_SRC
****** Running the Evaluator as a Program
       Given the evaluator, we have in our hands a description (expressed in Lisp) of the process by which Lisp expressions are evaluated.
       One advantage of expressing the evaluator as a program is that we can run the program. This gives up, running with Lisp,
       a working model of how Lisp itself evaluates expressions.
       This can serve as a framework for experimenting with evaluation rules, as we shall do later in this chapter.

       Our evaluator program reduces expressions ultimately to the application of primitive procedures. Therefore,
       all that we need to run the evaluator is to create a mechanism that calls on the underlying Lisp system to model the application of
       primitive procedures.

       There must be a binding for each primitive procedure name, so that when =eval= evaluates the operator of an application of a primitive,
       it will find an object to pass to =apply=.
       We thus set up a global environment that associates unique objects with the names of the primitive procedures that can appear in the
       expressions we will be evaluating. The global environment also includes bindings for the symbols =true= and =false=,
       so that they can be used as variables in expressions to be evaluated.

       #+NAME: setup-env
       #+BEGIN_SRC scheme
         (define (setup-environment)
           (let ((initial-env
                  (extend-environment (primitive-procedure-names)
                                      (primitive-procedure-objects)
                                      the-empty-environment)))
             (define-variable! 'true true initial-env)
             (define-variable! 'false false initial-env)
             initial-env))
       #+END_SRC

       It does matter how we represent the primitive procedure objects,
       so long as =apply= can identify and apply them by using the procedures =primitive-procedure?= and =apply-primitive-procedure=.
       We have chosen to represent a primitive procedure as a list beginning with the symbol =primitive= and containing a procedure
       in the underlying Lisp that implements that primitive.     

       #+NAME: primitive-procedure
       #+BEGIN_SRC scheme
         (define (primitive-procedure? proc)
           (tagged-list? proc 'primitive))

         (define (primitive-implementation proc) (cadr proc))
       #+END_SRC

       =Setup-environment= will get the primitive names and implementation procedures from a list:

       #+NAME: primitive-procedures
       #+BEGIN_SRC scheme
         ;; TODO add more
         (define primitive-procedures
           (list (list 'car car)
                 (list 'cdr cdr)
                 (list 'cons cons)
                 (list 'null? null?)
                 (list '+ +)
                 (list '- -)
                 (list '* *)
                 (list '/ /)))

         (define (primitive-procedure-names)
           (map car primitive-procedures))

         (define (primitive-procedure-objects)
           (map (lambda (proc) (list 'primitive (cadr proc))) primitive-procedures))
       #+END_SRC

       To apply a primitive procedure, we simply apply the implementation procedure to the arguments, using the underlying Lisp system:

       #+NAME: apply-primitive-procedure
       #+BEGIN_SRC scheme
         (define (apply-primitive-procedure proc args)
           (apply-in-underlying-scheme
            (primitive-implementation proc) args))
       #+END_SRC

       For convenience in running the metacircular evaluator, we provide a /driver loop/ that models the read-eval-print
       loop of the underlying Lisp system.
       #+NAME: driver-loop
       #+BEGIN_SRC scheme

         (define input-prompt ";; M-Eval input:")
         (define output-prompt ";; M-Eval value:")

         (define (prompt-for-input str)
           (newline) (newline) (display str) (newline))

         (define (announce-output str)
           (newline) (display str) (newline))

         (define (user-print object)
           (if (compound-procedure? object)
               (display (list 'compound-procedure
                              (procedure-parameters object)
                              (procedure-body object)
                              '<procedure-env>))
               (display object)))

         (define (driver-loop)
           (prompt-for-input input-prompt)
           (let ((input (read)))
             (let ((output (eval input the-global-environment)))
               (announce-output output-prompt)
               (user-print output)))
           (driver-loop))

       #+END_SRC

       #+NAME: apply-in-underlying-scheme
       #+BEGIN_SRC scheme
         ;; This has to be put before defining the metacircular apply
         (define apply-in-underlying-scheme apply)
       #+END_SRC

       The last step to run the =driver-loop= is to run the following two lines.
       #+NAME: run
       #+BEGIN_SRC scheme
         (define the-global-environment (setup-environment))
         (driver-loop)
       #+END_SRC
       
****** source code
       #+NAME: metacircularevaluator
       #+BEGIN_SRC scheme :tangle metacircular.scm :noweb yes
         <<apply-in-underlying-scheme>>
         <<eval>>
         <<apply>>
         <<list-of-values>>
         <<eval-if>>
         <<eval-sequence>>
         <<eval-assignment>>
         <<eval-definition>>
         <<eval-and>>
         <<eval-or>>
         <<self-evaluating-items>>
         <<variables>>
         <<quotations>>
         <<tagged-list>>
         <<assignments>>
         <<definitions>>
         <<lambda-expressions>>
         <<if-conditionals>>
         <<begin>>
         <<sequence->exp>>
         <<procedure-application>>
         <<cond-ex-4.5>>
         <<let-ex-4.6>>
         <<let-ex-4.7>>
         <<testing-of-predicates>>
         <<procedures>>
         <<env-1>>
         <<env-2>>
         <<env-3>>
         <<env-4>>
         <<env-5>>
         <<env-6>>
         <<setup-env>>
         <<primitive-procedure>>
         <<primitive-procedures>>
         <<apply-primitive-procedure>>
         <<driver-loop>>
         <<run>>
       #+END_SRC

*** Computer Systems: A Programmer's Perspective
**** 2.1
     #+BEGIN_SRC C
       #include <stdio.h>
       #include <string.h>

       typedef unsigned char *byte_pointer;

       void show_bytes(byte_pointer start, size_t len)
       {
         size_t i;
         for (i = 0; i < len; ++i) {
           printf(" %.2x", start[i]);
         }
         printf("\n");
       }

       void show_int(int x)
       {
         show_bytes((byte_pointer) &x, sizeof(int));
       }

       void show_float(float x)
       {
         show_bytes((byte_pointer) &x, sizeof(float));
       }

       void show_pointer(void *x)
       {
         show_bytes((byte_pointer) &x, sizeof(void *));
       }

       int main(int argc, char *argv[])
       {
         int val = 0x87654321;
         //show_int(val);
         byte_pointer valp = (byte_pointer) &val;
         show_bytes(valp, 1);
         show_bytes(valp, 2);
         show_bytes(valp, 3);

         const char *s = "abcdef";
         show_bytes((byte_pointer) s, strlen(s));

         return 0;
       }

     #+END_SRC

     #+RESULTS:
     | 21 |    |    |    |    |    |
     | 21 | 43 |    |    |    |    |
     | 21 | 43 | 65 |    |    |    |
     | 61 | 62 | 63 | 64 | 65 | 66 |

***** 2.1.7
      #+BEGIN_SRC C
        void inplace_swap(int *x, int *y)
        {
          ,*y = *x @
            }

      #+END_SRC

*** Machine Language for the Commodore 64, 128 and Other Commodore Computers (Revised and Expanded Edition)
**** First Concepts
***** Microprocesser Registers
      | PC         | 16 bits | The program counter tells where the next instruction will come from                  |
      | A, X and Y | 8 bits  | These registers hold data                                                            |
      | SR         |         | The status register, tells about the result of recent tests, data handling and so on |
      | SP         |         | The stack pointer keeps track of a temporary storage area.                           |
***** First Program Project
      Write a program to exchange contents of $0380 and $0381.

      #+begin_src asm
          lda $0380                     ; bring in first value
          ldx $0381                     ; bring in second value
          sta $0381                     ; store in opposite place
          stx $0380                     ; and again
      #+end_src
****** Translate this program into machine code.

       Here are some machine language op codes for the instructions we may use.
      
       | LDA | AD |
       | STA | 8D |
       | LDX | AE |
       | STX | 8E |
       | LDY | AC |
       | STY | 8C |
       | BRK | 00 |

       #+begin_src asm
           AD 80 03                        ; LDA $0380
           AE 81 03                        ; LDX $0381
           8D 81 03                        ; STA $0381
           8E 80 03                        ; STX $0380
       #+end_src

       Choosing a location. We will put our program into the cassette buffer, starting at address $033C (decimal 828)
****** MLM Commands
       | M 1000 1010 | Display memory from hex 1000 to 1010   |
       | R           | Display registers                      |
       | G 033C      | Go to 033C and start running a program |
****** Entering the Program
       In Vice, =>= is the command to write to memory.
       #+begin_src 
         > 033C AD 80 03 AE 81 03 8D 81 03 8E 80 03 00
       #+end_src
****** Preparation
       Write to memory 11 -> $0380, 99 -> $0381.
       #+begin_src 
         > 0380 11 99
       #+end_src

       Run program at $033C.
       #+begin_src asm
         G 033C
       #+end_src
**** Controlling Output
***** Prewritten subroutines
      | Address | Name   | What it does               |
      | $FFD2   | CHROUT | Outputs an ASCII character |
      | $FFE4   | GETIN  | Gets an ASCII character    |
      | $FFE1   | STOP   | Checks the RUN/STOP key    |
***** CHROUT - The Output Subroutine
      Address: $FFD2
      Action: Sends a copy of the character in the A register to the output channel.

      To print a letter X on the screen, we would need to follow these steps:
      1. Bring ASCII letter X ($58) into A register
      2. JSR to address $FFD2

***** A Print Project
      Print letter H on the screen.

      Use =a= (assemble) command in MLM to input the program into memory.
      =a 033C LDA #$48=

      =JSR $FFD2=

      =BRK=

****** Disassembler
       Type =d 033c= will disassemble memory into assembly language.
****** Linking with Basic
       To run the program, instead of typing =g 033c= from MLM, we can do it with basic =SYS 828= (828 is decimal of $033c).

       Let's distinguish 3 different types of subroutine calls:
       
       | GOSUB | calls a BASIC subroutine from a BASIC program             |
       | SYS   | calls a machine language subroutine from a BASIC program  |
       | JSR   | calls a machine language subroutine from machine language |
***** Loops
      Lets print HELLO followed by a RETURN.

      #+begin_src asm

          LDX #$00
          LDA $034A, X
          JSR $FFD2
          INX
          CPX #$06
          BNE $033E
          RTS
      #+end_src

      Then input data:
      #+begin_src 
       > 034A 48 45 4c 4c 4f 0d
      #+end_src

      Now run =SYS 828= and see "HELLO" printed.
***** Questions and Projects
      Clear screen ($93) and print "HO HO!".
      #+begin_src asm
          LDX #$00
          LDA $034A, X
          JSR $FFD2
          INX
          CPX #$08
          BNE $033E
          RTS
      #+end_src

      Then input data:
      #+begin_src 
       > 034A 93 48 4F 20 48 4F 21 0D
      #+end_src
**** Flags, Logic and Input
***** Z Flag
      The Z(zero) flag should have been called the equals flag.
      After any comparison (CPX, CPY or CMP), the Z flag will be
      set to "on" if the compared values are equal; otherwise it
      will be reset to "off".

      Sometimes the Z flag checks for equal to zero, this happens
      for every activity that may change one of the three data registers.
      Thus, any load command will affect the Z flag status, and also
      the increment and decrement instructions.

      If the Z flag is set "on", the BEQ(branch equals) instruction
      will branch to the specified address;otherwise it will be ignored
      and the next instruction in the sequence will be executed.
      If the Z flag is reset "off", the BNE instruction will branch.
***** C Flag
      The C(carry) flag should have been called the GE(great/equal) flag,
      since after a comparison(CPX, CPY or CMP), the C flag is set "on"
      if the register is greater than or equal to the value compared.
      If the register concerned is smaller, the C flag will be reset "off".
      
      When used in arithmetic, the C flag is properly named, since it acts
      as a "carry" bit between various columns as they are calculated.
    
      
      If the C flag is set "on", the BCS(branch carry set) instruction will
      branch to the specified address;otherwise it will be ignored and the
      next instruction in sequence will be be executed.
      If the C flag is reset "off", the BCC(branch carry clear) instruction
      will branch.
***** N Flag
      The N(negative) flag is set to indicate that a register has been given
      a value whose high bit is set.

      If the N flag is set "on", the BMI(branch minus) insruction will branch
      to the specified address;otherwise it will be ignored and the next instruction
      in sequence will be executed. If the N flag is reset "off", the BPL(branch plus)
      instruction will branch.
***** V Flag
      The V(overflow) flag should be called the SAO(signed arithmetic overflow) flag,
      since it is affected only by addition and subtraction commands, and is meaningful
      only if the numbers concerned are considered to be signed.

      If the V flag is set "on", the BVS(branch overflow set) instruction will branch
      to the specified address;otherwise it will be ignored.
      If the V flag is reset "off", the BVC(branch overflow clear) instruction will branch.
***** The Status Register
      | 7 | 6 | 5 | 4 | 3 | 2 | 1 | 0 |
      | N | V | - | B | D | I | Z | C |

      | N     | the N flag                                                                                                             |
      | V     | the V flag                                                                                                             |
      | Bit 5 | unused                                                                                                                 |
      | B     | "Break" indicator. When an interrupt occurs, this signals whether or not the interrupt was caused by a BRK instruction |
      | D     | Decimal mode indicator. Always off                                                                                     |
      | I     | Interrupt disable.                                                                                                     |
      | Z     | the Z flag                                                                                                             |
      | C     | the C flag                                                                                                             |
***** A Note on Comparison
      If we wish to compare two bytes with each other, we must perform a
      comparison. One value must be in a register (A, X or Y);the other must
      either be stored in memory, or must be an immediate value we use in the instruction.

      CMP - for A register
      CPX - for X register
      CPY - for Y register

      BEQ - branches if the two bytes are equal
      BNE - branches if the two bytes are not equal
      BCS(branch carry set) - branches if the value in the register is greater than or equal to the other value.
      BCC(branch carry clear) - branches if the value in the register is less than the other value.

      Suppose our program wanted to test the Y register for a value equal to or less than 5.

      #+begin_src asm
          CPY #$05
          BEQ ..somewhere
          BCC ..somewhere
      #+end_src

      which is equal to 

      #+begin_src asm
          CPY #$06
          BCC ..somewhere
      #+end_src
***** Logical Operations
     
      | AND | turns bits off  |
      | ORA | turns bits on   |
      | EOR | flips bits over |
***** AND - Logical AND to A
      Example: Turn off bits 4, 5 and 6 in the following value: $C7
      |     | 11000111 |
      |     | 10001111 |
      | AND | 10000111 |
      |     |  xxx     |
      Note that the bits marked have been forced to "off", while all other bits remain unchanged.
***** ORA - Logical OR to A
      Example: Turn on bits 4, 5, and 6 in the following value: $C7
      |     | 11000111 |
      |     | 01110000 |
      |ORA  | 11110111 |
      |     |  xxx     |
***** EOR - Exclusive OR to A
      | Original A Bit | Mask | Resulting A Bit |
      |----------------+------+-----------------|
      |              0 |    0 |               0 |
      |              1 |    0 |               1 |
      |              0 |    1 |               1 |
      |              1 |    1 |               0 |

      When mask is 0, the original bit in A is left unchanged.
      When mask is 1, the original bit in A is inverted.

      Example: Invert bits 4, 5 and 6 in the following value: $C7
      |     | 11000111 |
      |     | 01110000 |
      | EOR | 10110111 |
      |     |  xxx     |
***** Input: The GETIN Subroutine
      Subroutine: GETIN
      Address: $FFE4
      Action: Takes a character from the input channel and places it
              into the A register. The input channel is the keyboard input
              buffer unless arrangements have been made to switch it.

      The character received is usually ASCII. When read from the keyboard,
      the action is similar to a BASIC GET statement: one character will be taken
      from the buffer; it will not be shown on the screen. If no character is available
      from the keyboard input buffer, a value of binary zero will be put into the A register.
      The subroutine will not wait for a key to be pressed but will always return immediately.

      Registers: The A register will of course be affected. X and Y are likely
                 to be changed;do not have data in these when calling GETIN.
***** STOP
      Subroutine: STOP
      Address: $FFE1
      Action: Check the RUN/STOP key. If RUN/STOP is being pressed at that instant,
              the Z flag will be set when the subroutine returns.
      Registers: A will be affected. X will be affected only if the RUN/STOP key is being pressed.
      Status: Z signals whether RUN/STOP is being pressed.
***** Programming Project
      Write a subroutine that will wait for a numeric key to be pressed.
      All other keys (except RUN/STOP) will be ignored.

      #+begin_src asm
          A 033C JSR $FFE1
          A 033F BEQ $0351
          A 0341 JSR $FFE4
          A 0344 CMP #$30
          A 0346 BCC $033C
          A 0348 CMP #$3A
          A 034A BCS $033C
          A 034C JSR $FFD2
          A 034F AND #$0F
          A 0351 RTS
      #+end_src
**** Numbers, Arithmetic, and Subroutines
***** Numbers: Signed and Unsigned
      The most important concept is that you, the programmer, choose
      whether or not a number is to be considered a signed number
      (for a single byte, in the decimal range -128 to +127) or an
      unsigned integer (single-byte range 0 to 255).

      It makes no difference to the computer. If you consider a number
      signed, you may wish to test the sign using the N flag. If not, you
      won't do such a test.
***** Big Numbers: Multiple Bytes

      |         | unsigned          | signed                   |
      |---------+-------------------+--------------------------|
      | 1 byte  | 0 to 255          | -128 to +127             |
      | 2 bytes | 0 to 65535        | -32768 to +32767         |
      | 3 bytes | 0 to 16777215     | -8388608 to + 8388607    |
      | 4 bytes | to over 4 billion | -2 billion to +2 billion |

      When signed numbers are held in multiple bytes, the sign is the highest bit of the highest byte only.
***** Addition
      Rules:
      1. Before we start an addition sequence, clear the carry with CLC.
      2. If the numbers are more than one byte in size, start at the low byte and work
         up to the high ones. Addition will take place in the A register only;you may add the contents
         of an address or an immediate value. The carry flag will take care of any carries.
      3. When the addition sequence is complete, check for overflow:
         a. if the numbers are unsigned, a set C flag indicates overflow;
         b. if the numbers are signed, a set V flag indicates overflow;

      Example:

      Add 2 unsigned numbers located at address $0380 and $0381 and to place the result at $0382.
         
      #+begin_src asm
          CLC
          LDA $0380
          ADC $0381
          STA $0382
      #+end_src
      We might BCS to an overflow error routine, if desired.

      Add a two-byte number located at $03A0(low) and $03A1(high) to another two-byte number
      located at $03B0(low) and $03B1(high), placing the result at $03C0/1.

      #+begin_src asm
          CLC
          LDA $03A0
          ADC $03B0
          STA $03C0
          LDA $03A1
          ADC $03B1
          STA $03C1
      #+end_src
      Again, we might BCS to an overflow routine.

      If we had two-byte signed numbers in the same locations, we'd add them
      exactly the same way, using the same code as above. In this case, we'd check for
      overflow by adding the instruction BVS, which would branch to an error routine.
      The carry flag would have no meaning at the end of the addition sequence.
***** Subtraction
      Subtraction might be defined as "upside down" addition. The carry flag again serves to link the parts of a multibyte subtraction,
      but its role is reversed. The carry flag is sometimes called an "inverted borrow" when used in subtraction. Before performing a subtraction,
      we must set the C flag with SEC. If we worried about unsigned overflow, we look to confirm that the carry is set at the completion of the
      subtraction operation. If the carry is clear, there is a problem.

      Rules:

      1. Before we start a subtraction, set the carry with SEC.
      2. If the numbers are more than one byte in size, start at the
         low byte and work up to the high ones. Subtraction will
         take place in the A register only;you may subtract the contents of
         an address or an immediate value. The C flag will take care of any "borrows".
      3. When the subtraction sequence is complete, check for overflow:
         1. if the numbers are unsigned, a clear C flag indicates overflow;
         2. if the numbers are signed, a set V flag indicates overflow.

      Example:

      Subtract two unsigned numbers located at addresses $0380 and $0381 and place
      the result at $0382.

      #+begin_src asm
          SEC
          LDA $0380
          SBC $0381
          STA $0382
      #+end_src
      A BCC could go to an error routine.
***** Comparing Numbers
      If we have two unsigned numbers and wish to know which one is larger,
      we can use the appropriate compare instruction - CMP, CPX or CPY -
      and then check the carry flag. We've done this before. If the numbers
      are more than one byte long, however, it's not quite so easy.

      The easiest way to go about such a comparison is to subtract one
      number from the other. You need not keep the result; all you care
      about is the carry flag when the subtraction is complete. If the
      C flag is set, the first number is greater than or equal to the second
      number. Why? Because carry set indicated that the unsigned subtraction
      was legal; we have subtracted the two numbers and have obtained
      a positive (unsigned) result. On the other hand, if the C flag
      ends up clear, this would mean that the first number is less than
      the second. The subtraction couldn't take place correctly since
      the result - a negative number - cannot be represented in unsigned
      arithmetic.
***** Left Shift: Multiplication by Two

      - ASL (arithmetic shift left)
        - A zero bit is pushed into the low side of the byte
        - All bits move left one position
        - The bit that "falls out" of the byte moves into the carry.

      - ROL (rotate left)
        - Works exactly like ASL
        - Except that the carry bit is pushed into the next byte.

      Thus, we can hook two or more bytes together. If they hold a single
      multibyte number, we can double that number by starting at the
      low-order end. We ASL the first value and ROL the remainder.
      
***** Multiplication
      To multiply by ten, you first multiply by two;then multiply by two again.
      At this point, we have the original number times four. Now, add
      the original number, giving the original number times five.
      Multiply by two one last time and you've got it.

***** Right Shift and Rotate: Dividing by Two
      LSR(logical shift right) puts a zero into the left(high-order) bit,
      moves all the bits over to the right, and drops the leftover bit
      into carry.
      ROR(rotate right) puts the carry bit into the left bit, moves
      everything right, and drops the leftover bit into the carry once
      again. At the end of a right-shifting sequence, the final carry
      bit might be considered a remainder after dividing by two.

**** Address Modes
     Computer instructions come in two parts: the instruction itself, or
     /op/ code, and the address, or /operand/.

     The term /address mode/ refers to the way in which the instruction
     obtains information.

***** No Address: Implied Mode
      Instructions such as =INX= (increment X), =BRK= (break), and
      =TAY= (transfer A to Y) need no address;they make no memory
      reference and are complete in themselves. Such instructions occupy
      one byte of memory.
      
****** The Do-Nothing Instruction: NOP
       =NOP= (no operation) is an instruction that does nothing.
       Its op code is =$EA=. 

***** No Address: Accumulator Mode     
      We have observed that the shift and rotate instructions, ASL,
      ROL, LSR, and ROR, allow data manipulation in either the A
      register or directly in memory. When we want to use the A register
      , or /accumulator/, you should note this fact as you code your
      program. For example, you would write =ASL A= or sometimes just =ASL=.

      Where accumulator mode addressing is used, it has the same
      characteristics as implied addressing: the whole instruction fits
      into one byte.

      Where the shift/rotate instruction refers to a memory location, an
      address will of course be needed. These address modes will be
      described later.

      Other than the shift and rotate instructions, there is one other
      set of instructions that manipulates memory directly. You may recall
      =INX=, =INY=, =DEX=, =DEY= increment or decrement an index register.

      =INC= (increment memory) adds one to any memory location. =DEC=
      (decrement memory) subtracts one from any memory location.

      
***** Not Quite an Address: Immediate Mode
      Coding such as =LDA #$34= does not reference a memory address.
      Instead, it designates a specific value. An instruction with
      immediate addressing takes up two bytes: one for the op code
      and the second for the immediate value.

***** A Single Address: Absolute Mode
      An instruction might specify any address within memory - from
      $0000 to $FFFF - and handle information from that address.
      Giving the full address is called /absolute addressing/;if you like,
      you can deal with information absolutely anywhere in memory.

****** Zero-Page Mode
       A hexadecimal address such as $0381 is sixteen bits long and
       takes up two bytes of memory. We call the high byte ($03), the
       "memory page" of the address. Addresses such as $004C and $00F7
       are in page zero. We may write $4C and $F7 for short.

****** A Range of 256 Addresses: Absolute, Indexed Mode
       We give an absolute address, and then indicate that the contents
       of X or Y should be added to this address to give an /effective address/.
       
       Indexing is used only for data handling;it's available for such
       activities as load and store, but not for branching or jump.

       An instruction using absolute, indexed addressing can reach up
       to 256 locations. Register X and Y may hold values from 0 to 255,
       so that the effective address may range from the address given 
       to 255 locations higher.

       Indexing always increases the address;there is no such thing as
       a negative index when used with an absolute address.

****** All of Zero Page: Zero-Page, Indexed
       Zero-page, indexed addressing seems at first glance to be similar
       to the absolute, indexed mode. The address given (this time in
       zero-page) has the contents of the selected index added to it.
       But there's a difference: in this case, the effective address
       can never leave zero page.

       This mode usually uses the X register; only two instructions, LXD
       and STX, use the Y register for zero-page, indexed addressing.
       In either case, the index is added to the zero-page address; if 
       the total goes beyond zero page, the address "wraps around". As
       an example, if an instruction is coded =LDA $E0, X=, and the X
       register contains 50 at the time of execution, the effective
       address will be $0030. The total($E0 + $50 or $130) will be trimed
       back into zero page.

       On Commodore machines, zero page is fairly well occupied. There's
       limited opportunity to use zero-page, indexed addressing.

*** Grokking Algorithms
**** Binary Search
#+begin_src python :results output

  def binary_search(list, item):
      low = 0
      high = len(list) - 1
      while (low <= high):
          mid = (low + high) // 2
          if (list[mid] == item):
              return mid
          else:
              if (list[mid] > item):
                  high = mid - 1
              else:
                  low = mid + 1
      return None

  print(binary_search([1, 2, 3, 4, 5], 3))
#+end_src

#+RESULTS:
: 2
